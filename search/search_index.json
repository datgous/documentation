{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Witnet ecosystem! \u00b6 The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information on behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which incentivizes network players to abide by the protocol and makes them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum . Node operators, a.k.a. Witnesses \u00b6 The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts. Developers \u00b6 The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet , e.g. integrate Witnet into DeFi protocols. Build bridges between Witnet and other blockchains, so that contracts in those networks can query the Witnet decentralized oracle. Contribute to Witnet-Rust or Sheikah . Witnet Foundation \u00b6 Witnet Foundation is a non-profit dedicated to stewarding the advancement of the Witnet oracle protocol and ecosystem, as well as the broader Web3 space, with a focus on fostering research and development of technologies that enhance the decentralization of communications and financial infrastructure in search of more freedom for the individual. Witnet Foundation is directly in charge of the development of Witnet-Rust, as well as nurturing and funding an engaged and diverse ecosystem around the Witnet protocol. Other significant actors in the development community \u00b6 Beyond Witnet Foundation, there are other corporations and individuals who contribute significantly to key parts of the ecosystem: OtherPlane Labs , the software development startup now in charge of the development of the Sheikah witnet wallet . Dr. CPU, the anonymous developer (or developers) who built and operates the Witnet Block Explorer . The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many ways to get involved !","title":"Ecosystem"},{"location":"#welcome-to-the-witnet-ecosystem","text":"The Witnet protocol enables a network of computers to act as a decentralized oracle that retrieves, attests and delivers information on behalf of smart contracts in a tamper-resistant way. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger for the operation of the protocol as well as for the wit token, which incentivizes network players to abide by the protocol and makes them liable for any misbehavior. \u2014 Witnet Whitepaper Active network participants earn wit tokens for fulfilling the data retrieval, attestation and delivery tasks coming from different smart contract platforms such as Ethereum .","title":"Welcome to the Witnet ecosystem!"},{"location":"#node-operators-aka-witnesses","text":"The Witnet blockchain is free, open, and neutral. That is, You can run your own node and mine blocks on the Witnet blockchain . Every node maintains the history of all the transactions on the blockchain. Additionally, every node in the Witnet network can participate in witnessing , i.e. earning wit tokens in exchange of retrieving, aggregating and delivering data points from public APIs into smart contracts.","title":"Node operators, a.k.a. Witnesses"},{"location":"#developers","text":"The Witnet ecosystem welcomes developers of all kind of backgrounds: from people who contribute to Witnet-Rust or Sheikah to those who want to connect their Ethereum smart contracts to external APIs . Developers can: Build Witnet clients. Build applications to interact with a Witnet client. Write Ethereum smart contracts that use Witnet , e.g. integrate Witnet into DeFi protocols. Build bridges between Witnet and other blockchains, so that contracts in those networks can query the Witnet decentralized oracle. Contribute to Witnet-Rust or Sheikah .","title":"Developers"},{"location":"#witnet-foundation","text":"Witnet Foundation is a non-profit dedicated to stewarding the advancement of the Witnet oracle protocol and ecosystem, as well as the broader Web3 space, with a focus on fostering research and development of technologies that enhance the decentralization of communications and financial infrastructure in search of more freedom for the individual. Witnet Foundation is directly in charge of the development of Witnet-Rust, as well as nurturing and funding an engaged and diverse ecosystem around the Witnet protocol.","title":"Witnet Foundation"},{"location":"#other-significant-actors-in-the-development-community","text":"Beyond Witnet Foundation, there are other corporations and individuals who contribute significantly to key parts of the ecosystem: OtherPlane Labs , the software development startup now in charge of the development of the Sheikah witnet wallet . Dr. CPU, the anonymous developer (or developers) who built and operates the Witnet Block Explorer . The Witnet community is open to everyone. Even if you are not a developer or node operator, there are many ways to get involved !","title":"Other significant actors in the development community"},{"location":"chains/conflux/addresses/","text":"Witnet Addresses on Conflux Network \u00b6 Conflux smart contracts can send oracle queries (aka data requests ) to the Witnet decentralized oracle using the witnet-ethereum-bridge Solidity library. The most convenient way to use the witnet-ethereum-bridge library is through the Witnet Truffle Box , because it allows writing Witnet data requests using Javascript, which is automatically compiled to Witnet byte code and then wrapped in a Solidity contract that you can easily import from your own contracts. The Witnet Truffle Box also abstracts away the complexity of having to instantiate or link the Witnet contracts listed here. These addresses are provided for reference, just in case someone prefers not to use the Witnet Truffle Box and rather talk to the Witnet Request Board and other contracts directly using the interfaces in witnet-ethereum-bridge . Conflux Mainnet - Tethys \u00b6 Witnet is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned! Conflux Testnet \u00b6 Main contracts \u00b6 Witnet: cfxtest:ace03e0bd2cnkna0e16c769rb6mpb18b46nnfg8mck WitnetRequestBoard: cfxtest:acee21t6kvabde2rzrgmt4wf43nxuxp00anv17p79h WitnetRequestBoardProxy: cfxtest:acctgrbsj2bgnyrcsh8b1zx2yru4wjessjjrmhmpe0 Public price feeds \u00b6 BtcUsdPriceFeed: cfxtest:acexkt9t0dm7tzhv9t1znbnc83ehtb703u9pyvd0cd EthUsdPriceFeed: cfxtest:achf22mnyxrkt4bd4xb9b1fufwdw3bhg2pe445me8s","title":"Addresses"},{"location":"chains/conflux/addresses/#witnet-addresses-on-conflux-network","text":"Conflux smart contracts can send oracle queries (aka data requests ) to the Witnet decentralized oracle using the witnet-ethereum-bridge Solidity library. The most convenient way to use the witnet-ethereum-bridge library is through the Witnet Truffle Box , because it allows writing Witnet data requests using Javascript, which is automatically compiled to Witnet byte code and then wrapped in a Solidity contract that you can easily import from your own contracts. The Witnet Truffle Box also abstracts away the complexity of having to instantiate or link the Witnet contracts listed here. These addresses are provided for reference, just in case someone prefers not to use the Witnet Truffle Box and rather talk to the Witnet Request Board and other contracts directly using the interfaces in witnet-ethereum-bridge .","title":"Witnet Addresses on Conflux Network"},{"location":"chains/conflux/addresses/#conflux-mainnet-tethys","text":"Witnet is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned!","title":"Conflux Mainnet - Tethys"},{"location":"chains/conflux/addresses/#conflux-testnet","text":"","title":"Conflux Testnet"},{"location":"chains/conflux/addresses/#main-contracts","text":"Witnet: cfxtest:ace03e0bd2cnkna0e16c769rb6mpb18b46nnfg8mck WitnetRequestBoard: cfxtest:acee21t6kvabde2rzrgmt4wf43nxuxp00anv17p79h WitnetRequestBoardProxy: cfxtest:acctgrbsj2bgnyrcsh8b1zx2yru4wjessjjrmhmpe0","title":"Main contracts"},{"location":"chains/conflux/addresses/#public-price-feeds","text":"BtcUsdPriceFeed: cfxtest:acexkt9t0dm7tzhv9t1znbnc83ehtb703u9pyvd0cd EthUsdPriceFeed: cfxtest:achf22mnyxrkt4bd4xb9b1fufwdw3bhg2pe445me8s","title":"Public price feeds"},{"location":"chains/conflux/price-feeds/","text":"Witnet Price Feeds on Conflux Network \u00b6 Witnet Foundation operates a series of public price feeds in cooperation with Conflux Network both for showcasing the capabilities of the Witnet oracle,and as a public service for the broader Conflux community. All Witnet price feeds comply with the ERC-2362 interface: a standard interface for price feeds, cooperatively envisioned by Witnet, Tellor, Band, Razor and other oracles. Therefore, using any of these price feeds is as simple as: pragma solidity >= 0.5.0 < 0.9.0 ; import \"ado-contracts/contracts/interfaces/IERC2362.sol\" ; contract MyContract { function readFromPriceFeed () external view returns ( int256 ) { IERC2362 priceFeed = IERC2362 ( \"<address of the price feed>\" ); bytes32 assetID = bytes32 ( hex ( \"<asset ID>\" )); int256 value = priceFeed . valueFor ( assetID ); return value ; } } The available asset IDs for each of the public price feeds are also listed down below. A full list of asset IDs can be found in ADOIP-0010 . Floats and decimal digits As Solidity does not currently support float types, all prices are provided as int256 , with a specific number of decimal digits. For example, if the BTC/USD price is 31371.21 , the BTC/USD contract below will give 31371210 because it is using 3 decimal digits. BTC/USD \u00b6 Source code: Solidity contract Witnet data request Asset ID: 637b7efb6b620736c247aaa282f3898914c0bef6c12faff0d3fe9d4bea783020 Decimal digits: 3 Conflux Mainnet - Tethys \u00b6 This price feed is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned! Conflux Testnet \u00b6 Contract address: cfxtest:acexkt9t0dm7tzhv9t1znbnc83ehtb703u9pyvd0cd ETH/USD \u00b6 Source code: Solidity contract Witnet data request Asset ID: dfaa6f747f0f012e8f2069d6ecacff25f5cdf0258702051747439949737fc0b5 Decimal digits: 3 Conflux Mainnet - Tethys \u00b6 This price feed is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned! Conflux Testnet \u00b6 Contract address: cfxtest:achf22mnyxrkt4bd4xb9b1fufwdw3bhg2pe445me8s","title":"Price Feeds"},{"location":"chains/conflux/price-feeds/#witnet-price-feeds-on-conflux-network","text":"Witnet Foundation operates a series of public price feeds in cooperation with Conflux Network both for showcasing the capabilities of the Witnet oracle,and as a public service for the broader Conflux community. All Witnet price feeds comply with the ERC-2362 interface: a standard interface for price feeds, cooperatively envisioned by Witnet, Tellor, Band, Razor and other oracles. Therefore, using any of these price feeds is as simple as: pragma solidity >= 0.5.0 < 0.9.0 ; import \"ado-contracts/contracts/interfaces/IERC2362.sol\" ; contract MyContract { function readFromPriceFeed () external view returns ( int256 ) { IERC2362 priceFeed = IERC2362 ( \"<address of the price feed>\" ); bytes32 assetID = bytes32 ( hex ( \"<asset ID>\" )); int256 value = priceFeed . valueFor ( assetID ); return value ; } } The available asset IDs for each of the public price feeds are also listed down below. A full list of asset IDs can be found in ADOIP-0010 . Floats and decimal digits As Solidity does not currently support float types, all prices are provided as int256 , with a specific number of decimal digits. For example, if the BTC/USD price is 31371.21 , the BTC/USD contract below will give 31371210 because it is using 3 decimal digits.","title":"Witnet Price Feeds on Conflux Network"},{"location":"chains/conflux/price-feeds/#btcusd","text":"Source code: Solidity contract Witnet data request Asset ID: 637b7efb6b620736c247aaa282f3898914c0bef6c12faff0d3fe9d4bea783020 Decimal digits: 3","title":"BTC/USD"},{"location":"chains/conflux/price-feeds/#conflux-mainnet-tethys","text":"This price feed is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned!","title":"Conflux Mainnet - Tethys"},{"location":"chains/conflux/price-feeds/#conflux-testnet","text":"Contract address: cfxtest:acexkt9t0dm7tzhv9t1znbnc83ehtb703u9pyvd0cd","title":"Conflux Testnet"},{"location":"chains/conflux/price-feeds/#ethusd","text":"Source code: Solidity contract Witnet data request Asset ID: dfaa6f747f0f012e8f2069d6ecacff25f5cdf0258702051747439949737fc0b5 Decimal digits: 3","title":"ETH/USD"},{"location":"chains/conflux/price-feeds/#conflux-mainnet-tethys_1","text":"This price feed is not live yet on Conflux mainnet, but will be deployed soon. Stay tuned!","title":"Conflux Mainnet - Tethys"},{"location":"chains/conflux/price-feeds/#conflux-testnet_1","text":"Contract address: cfxtest:achf22mnyxrkt4bd4xb9b1fufwdw3bhg2pe445me8s","title":"Conflux Testnet"},{"location":"developer/contributing/","text":"Contributing to Witnet \u00b6 Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document. Code of conduct \u00b6 Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well. I just have a question \u00b6 Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response. How can I contribute? \u00b6 Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma. Reporting bugs \u00b6 This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having. How do I submit a good bug report? \u00b6 Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version? Suggesting enhancements \u00b6 This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible. How Do I Submit A Good Enhancement Suggestion? \u00b6 Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package. Your First Code Contribution \u00b6 Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two. Sending a Pull Request \u00b6 Commit messages convention \u00b6 We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs: add RADON `FLOAT_TOSTRING` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503 PGP-signing your commits \u00b6 All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"Contributing"},{"location":"developer/contributing/#contributing-to-witnet","text":"Thank you for joining the Witnet community and showing interest in making your first contribution! The following is a set of guidelines and helpful pointers for contributing to Witnet. The keyword here is guidelines , not rules. As such, use your best judgement and feel free to propose changes to even this document.","title":"Contributing to Witnet"},{"location":"developer/contributing/#code-of-conduct","text":"Everyone participating in this project is governed by the Witnet Code of Conduct . By participating, you are expected to uphold this code as well.","title":"Code of conduct"},{"location":"developer/contributing/#i-just-have-a-question","text":"Please don't file an issue with questions.It's easier for you and for us if you go directly to our Discord server or Telegram group , since it will keep our repositories clean and you will get a faster response.","title":"I just have a question"},{"location":"developer/contributing/#how-can-i-contribute","text":"Find an area you can help with and do it. Open source is about collaboration and open participation. Try to make your code look like what already exists and submit a pull request on GitHub . The list of issues is a good place to start, especially the ones tagged as \" good first issue \" or \"help wanted\" (but don't let that stop you from looking at others). If you're looking for additional ideas, try to search TODO comments for suggestions on minor to major improvements. grep is your friend. Pull requests adding more tests or documentation are rewarded with an immense amount of positive karma.","title":"How can I contribute?"},{"location":"developer/contributing/#reporting-bugs","text":"This section guides you through submitting a bug report. This helps contributors and maintainers understand your report, reproduce the behavior, and in turn squash the bug. Before submitting a bug report, please make sure that you've searched through the issues and that there isn't already an issue describing the same issue you are having.","title":"Reporting bugs"},{"location":"developer/contributing/#how-do-i-submit-a-good-bug-report","text":"Bugs are tracked as GitHub issues . Explain the problem and include additional details to help maintainers reproduce the problem: Use a clear and descriptive title for the issue to identify the problem. Describe the exact steps which reproduce the problem in as many details as possible. Provide specific examples to demonstrate the steps. Include links to files or GitHub projects, or copy/pasteable snippets, which you use in those examples. If you're providing snippets in the issue, use Markdown code blocks. Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior. Explain which behavior you expected to see instead and why. Post a screenshot or a dump of the console when possible and suitable. If the problem wasn't triggered by a specific action, describe what you were doing before the problem happened and share more information using the guidelines below. Provide more context by answering these questions: Did the problem start happening recently (e.g. after updating to a new version) or was this always a problem? If the problem started happening recently, can you reproduce the problem in an older version of Witnet-rust? What's the most recent version in which the problem doesn't happen? Can you reliably reproduce the issue? If not, provide details about how often the problem happens and under which conditions it normally happens. Are you running witnet-rust from a pre-compiled binary or from the source code? What's your operating system and version?","title":"How do I submit a good bug report?"},{"location":"developer/contributing/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion, including completely new features and minor improvements to existing functionality. Following these guidelines helps maintainers and the community understand your suggestion. Before creating enhancement suggestions, please double check that there is not already an existing feature suggestion for your feature, as you might find out that you don't need to create one. When you are creating an enhancement suggestion, please include as many details as possible.","title":"Suggesting enhancements"},{"location":"developer/contributing/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues. Create an issue on that repository and provide the following information: Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Provide specific examples to demonstrate the steps. Include copy/pasteable snippets which you use in those examples, as Markdown code blocks. Describe the current behavior and explain which behavior you expected to see instead and why. Explain why this enhancement would be useful to most users and isn't something that can or should be implemented as a community package.","title":"How Do I Submit A Good Enhancement Suggestion?"},{"location":"developer/contributing/#your-first-code-contribution","text":"Unsure where to begin contributing? You can start by looking through these good first issue issues: Good first issue - issues which should only require a few lines of code, and a test or two.","title":"Your First Code Contribution"},{"location":"developer/contributing/#sending-a-pull-request","text":"","title":"Sending a Pull Request"},{"location":"developer/contributing/#commit-messages-convention","text":"We use a commit message convention to make our commit history easier to understand for everyone and allow for automatic generation of changelogs. Examples These are some examples of good commit messages: feat(mining): use a random nonce as input in mint transactions BREAKING CHANGE: former mint transactions containing no inputs will be rendered invalid refactor(config): make `config` actor return settings as `Option`s docs: add RADON `FLOAT_TOSTRING` opcode this operator converts any floating point number into a UTF8 string chore(cargo): upgrade `actix` to version 0.8.1 fix #503","title":"Commit messages convention"},{"location":"developer/contributing/#pgp-signing-your-commits","text":"All commits in the Witnet project repositories need to be signed by their authors using PGP. Tip To configure your Git client to sign commits by default for a local repository, in Git versions 2.0.0 and above, run git config commit.gpgsign true . To sign all commits by default in any local repository on your computer, run git config --global commit.gpgsign true . To store your GPG key passphrase so you don't have to enter it every time you sign a commit, we recommend using the following tools: For Mac users, the GPG Suite allows you to store your GPG key passphrase in the Mac OS Keychain. For Windows users, the Gpg4win integrates with other Windows tools. You can also manually configure gpg-agent to save your GPG key passphrase, but this doesn't integrate with Mac OS Keychain like ssh-agent and requires more setup. If you have multiple keys or are attempting to sign commits or tags with a key that doesn't match your committer identity, you should tell Git about your signing key .","title":"PGP-signing your commits"},{"location":"developer/from-source/","text":"Running witnet-rust from source code \u00b6 Install compilation dependencies \u00b6 Rust \u00b6 witnet-rust is being developed using the Rust programming language. You need to install Rust on your system to be able to compile the source code. Follow installation instructions for your operating system provided on rustup.rs Compilation dependencies \u00b6 GNU/Linux (apt) apt install -y clang git libssl-dev protobuf-compiler librocksdb-dev pkg-config macOS xcode-select --install brew install git openssl protobuf rocksdb Clone source code from Witnet GitHub repository \u00b6 HTTPS git clone https://github.com/witnet/witnet-rust.git cd witnet-rust SSH git clone git@github.com:witnet/witnet-rust.git cd witnet-rust GitHub CLI gh repo clone witnet/witnet-rust cd witnet-rust Get the latest genesis_block.json \u00b6 cURL curl https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json -o genesis_block.json wget wget https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json Compile and run with cargo \u00b6 By default, this line will run a Witnet node and connect to the Testnet using the default configuration: cargo run node server For more witnet-rust commands you can read the witnet-rust CLI documentation . Building a release \u00b6 This one-liner will build a releasable standalone binary compatible with the architecture of your computer's processor: cargo build --release The resulting binary will be located at ./target/release/witnet .","title":"Compile from source code"},{"location":"developer/from-source/#running-witnet-rust-from-source-code","text":"","title":"Running witnet-rust from source code"},{"location":"developer/from-source/#install-compilation-dependencies","text":"","title":"Install compilation dependencies"},{"location":"developer/from-source/#rust","text":"witnet-rust is being developed using the Rust programming language. You need to install Rust on your system to be able to compile the source code. Follow installation instructions for your operating system provided on rustup.rs","title":"Rust"},{"location":"developer/from-source/#compilation-dependencies","text":"GNU/Linux (apt) apt install -y clang git libssl-dev protobuf-compiler librocksdb-dev pkg-config macOS xcode-select --install brew install git openssl protobuf rocksdb","title":"Compilation dependencies"},{"location":"developer/from-source/#clone-source-code-from-witnet-github-repository","text":"HTTPS git clone https://github.com/witnet/witnet-rust.git cd witnet-rust SSH git clone git@github.com:witnet/witnet-rust.git cd witnet-rust GitHub CLI gh repo clone witnet/witnet-rust cd witnet-rust","title":"Clone source code from Witnet GitHub repository"},{"location":"developer/from-source/#get-the-latest-genesis_blockjson","text":"cURL curl https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json -o genesis_block.json wget wget https://raw.githubusercontent.com/witnet/genesis_block/master/latest/genesis_block.json","title":"Get the latest genesis_block.json"},{"location":"developer/from-source/#compile-and-run-with-cargo","text":"By default, this line will run a Witnet node and connect to the Testnet using the default configuration: cargo run node server For more witnet-rust commands you can read the witnet-rust CLI documentation .","title":"Compile and run with cargo"},{"location":"developer/from-source/#building-a-release","text":"This one-liner will build a releasable standalone binary compatible with the architecture of your computer's processor: cargo build --release The resulting binary will be located at ./target/release/witnet .","title":"Building a release"},{"location":"developer/integrations/","text":"Witnet-rust integration quick guide \u00b6 This is intended for developers looking forward to integrate their software with Witnet and the WIT token in such a way that they can manage addresses, balances, and create and verify transactions. Foreseeably, this is the case for wallets, exchanges, atomic swaps, mixers, etc. Running Witnet-Rust \u00b6 The Witnet Foundation-supported reference implementation of the Witnet protocol is Witnet-Rust . Witnet-Rust can be easily run: as a Docker container as a Docker-compose service as a SystemD service compiling from source code Witnet-Rust components \u00b6 Witnet-Rust contains two different components that provide different degrees of wallet functionality: node , which implements a Witnet full node with an internal single-account, single-address wallet and a JSON-RPC API over a TCP. wallet , which implements a BIP-32 compliant, multi-account, multi-address Hierarchical Deterministic wallet, and a JSON-RPC API over WebSockets. Witnet-Rust node component \u00b6 The Witnet-Rust node component is standalone \u2014 you can run it on its own and it will provide full-node functionality: syncing up the Witnet block chain, validate transactions and blocks in real time, and (optionally) propose blocks. Integration architecture: [YOUR APP] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] Once a node instance is fully synced, its JSON-RPC over TCP API offers a minimal single-account, single-address wallet. Running a Witnet-Rust node with the JSON-RPC API exposed on local port 21338 can easily be achieved with this Docker one-liner: docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --publish 21338:21338 \\ --restart always \\ witnet/witnet-rust Here is a quick guide on how to interact with a node using the JSON-RPC interface using any TCP client. There is also a command line client (CLI) that exposes all the node functionality and uses the JSON-RPC API under the hood. Witnet-Rust wallet component \u00b6 The Witnet-Rust wallet component is NOT standalone. It requires a connection to an instance of the node component that will act as its \"backend\": Integration architecture: [YOUR APP] \u2192 [WITNET-RUST WALLET] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] Witnet Foundation operates a publicly available node instance that acts as the backend for the wallet component contained within the Sheikah Witnet wallet desktop app , which follows exactly the same architecture: Sheikah Wallet app architecture: [SHEIKAH UI*] \u2192 [WITNET-RUST WALLET*] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] * The Sheikah UI and the Witnet-Rust wallet are run in the user's computer. For users looking for the maximum degree of privacy, it is recommended that they run their own instance of the node component, because otherwise they may be disclosing their addresses and balances to 3 rd parties, as the queries between the wallet and node components need to be sent over the Internet. The JSON-RPC API of the wallet component is different than the one from the node not because it has much more advanced wallet functionality, and uses a WebSockets transport instead of plain TCP (this is to enable web wallets and similar apps). A full reference of the Wallet API can be found here .","title":"Integration guide"},{"location":"developer/integrations/#witnet-rust-integration-quick-guide","text":"This is intended for developers looking forward to integrate their software with Witnet and the WIT token in such a way that they can manage addresses, balances, and create and verify transactions. Foreseeably, this is the case for wallets, exchanges, atomic swaps, mixers, etc.","title":"Witnet-rust integration quick guide"},{"location":"developer/integrations/#running-witnet-rust","text":"The Witnet Foundation-supported reference implementation of the Witnet protocol is Witnet-Rust . Witnet-Rust can be easily run: as a Docker container as a Docker-compose service as a SystemD service compiling from source code","title":"Running Witnet-Rust"},{"location":"developer/integrations/#witnet-rust-components","text":"Witnet-Rust contains two different components that provide different degrees of wallet functionality: node , which implements a Witnet full node with an internal single-account, single-address wallet and a JSON-RPC API over a TCP. wallet , which implements a BIP-32 compliant, multi-account, multi-address Hierarchical Deterministic wallet, and a JSON-RPC API over WebSockets.","title":"Witnet-Rust components"},{"location":"developer/integrations/#witnet-rust-node-component","text":"The Witnet-Rust node component is standalone \u2014 you can run it on its own and it will provide full-node functionality: syncing up the Witnet block chain, validate transactions and blocks in real time, and (optionally) propose blocks. Integration architecture: [YOUR APP] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] Once a node instance is fully synced, its JSON-RPC over TCP API offers a minimal single-account, single-address wallet. Running a Witnet-Rust node with the JSON-RPC API exposed on local port 21338 can easily be achieved with this Docker one-liner: docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --publish 21338:21338 \\ --restart always \\ witnet/witnet-rust Here is a quick guide on how to interact with a node using the JSON-RPC interface using any TCP client. There is also a command line client (CLI) that exposes all the node functionality and uses the JSON-RPC API under the hood.","title":"Witnet-Rust node component"},{"location":"developer/integrations/#witnet-rust-wallet-component","text":"The Witnet-Rust wallet component is NOT standalone. It requires a connection to an instance of the node component that will act as its \"backend\": Integration architecture: [YOUR APP] \u2192 [WITNET-RUST WALLET] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] Witnet Foundation operates a publicly available node instance that acts as the backend for the wallet component contained within the Sheikah Witnet wallet desktop app , which follows exactly the same architecture: Sheikah Wallet app architecture: [SHEIKAH UI*] \u2192 [WITNET-RUST WALLET*] \u2192 [WITNET-RUST NODE] \u2192 [WITNET NETWORK] * The Sheikah UI and the Witnet-Rust wallet are run in the user's computer. For users looking for the maximum degree of privacy, it is recommended that they run their own instance of the node component, because otherwise they may be disclosing their addresses and balances to 3 rd parties, as the queries between the wallet and node components need to be sent over the Internet. The JSON-RPC API of the wallet component is different than the one from the node not because it has much more advanced wallet functionality, and uses a WebSockets transport instead of plain TCP (this is to enable web wallets and similar apps). A full reference of the Wallet API can be found here .","title":"Witnet-Rust wallet component"},{"location":"developer/wallet-api/","text":"Wallet Server API \u00b6 The wallet exposes a JSON-RPC API over Websocket by default at the URL 127.0.0.1:21338 . It can be set in the Witnet configuration file as follows: [wallet] node_url = \"127.0.0.1:21338\" Summary \u00b6 Method Name Request Params Response close_session session_id success create_data_request session_id , wallet_id , request , fee , ( fee_type ) bytes , transaction , transaction_id create_mnemonics length mnemonics create_vtt session_id , wallet_id , fee , ( fee_type ), [ address , value , ( time_lock )], ( utxo_strategy ), ( selected_utxos ) bytes , metadata , transaction , transaction_id create_wallet ( name ), ( description ), seed_source , seed_data , password , ( overwrite ), ( backup_password ), ( birth_date ) wallet_id delete_wallet session_id , wallet_id success export_master_key session_id , wallet_id , password private_key generate_address session_id , wallet_id , ( external ) address , path get session_id , wallet_id , key value get_addresses session_id , wallet_id , ( offset ), ( limit ), ( external ) address[] , total get_balance session_id , wallet_id confirmed , local , unconfirmed get_transactions session_id , wallet_id , ( offset ), ( limit ) transactions[] , total get_utxo_info session_id , wallet_id output_info[] get_wallet_infos (none) wallet_info[] lock_wallet session_id , wallet_id success refresh_session session_id success resync_wallet session_id , wallet_id success rpc.off ( subscription_id[] ) (none) rpc.on session_id ( subscription_id ) run_rad_request request result send_transaction session_id , wallet_id , transaction balance_movement , jsonrpc_result set session_id , wallet_id , key , value (none) shutdown session_id (none) sign_data session_id , wallet_id , data , extended_pk chaincode , public_key , signature unlock_wallet wallet_id , password session_id , session_expiration_secs , ... update_wallet session_id , wallet_id , ( name ), ( description ) success validate_mnemonics seed_source , seed_data , ( backup_password ) exist , wallet_id Wallet API Endpoints \u00b6 create_data_request \u00b6 The method create_data_request creates a data request transaction object. It contains all required cryptographic information in order to be later sent to a Witnet node (e.g. by using the method send_transaction ). Request with parameters: session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . wallet_id : String , the ID associated to the wallet. See get_wallet_infos . fee : number , amount in nanoWitswill be earned by the miner that publishes the request. fee_type : (optional) String , fee type chosen between weighted or absolute . Defaults to weighted if not inserted. request : DataRequestOutput , a struct with required data request fields. data_request : RADRequest , data request with CBOR codification. witness_reward : number , reward in nanoWits to the witnesses of the data request. witnesses : number , minimum number of witnet nodes that must perform the request. commit_and_reveal_fee : number , amount in nanoWits that will be earned by the miner for each each valid commitment and reveal transaction. min_consensus_percentage : number , , minimum of consensus required to consider the request as valid. collateral : number , collateral amount in nanoWits. More information about the parameters can be found in the tutorial of data request parameters fine-tuning . As an example, this data request created a data request that retrives the last Bitcoin blockhash from two different sources using three witnesses: { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_data_request\" , \"id\" : \"1\" , \"params\" : { \"session_id\" : \"678f4320d8f8ff1a9f86f56f20f0c6a76fba92db0e8e5b1fd2f21092de985f3e\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"request\" : { \"data_request\" : { \"time_lock\" : 0 , \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://blockchain.info/q/latesthash\" , \"script\" : [ 128 ] }, { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://api-r.bitcoinchain.com/v1/status\" , \"script\" : [ 130 , 24 , 119 , 130 , 24 , 103 , 100 , 104 , 97 , 115 , 104 ] } ], \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"tally\" : { \"filters\" : [ { \"op\" : 8 , \"args\" : [] } ], \"reducer\" : 2 } }, \"witness_reward\" : 1000 , \"witnesses\" : 3 , \"commit_and_reveal_fee\" : 10 , \"min_consensus_percentage\" : 51 , \"collateral\" : 1000000000 }, \"fee\" : 0 } } The create_data_request response will include the following data: bytes : String , data request bytes represented in hexadecimal format. transaction : DataRequest , all transactional information regarding the created data request. body : Includes the data request output, inputs and outputs of the transaction. signatures : The signature of the transaction and the public key transaction_id : String , unique transaction identifier. Example of a create_data_request response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"bytes\" : \"1297030aa0020a280a260a220a201a79a8689f9ede624043993b620e6042d2b7e80573c19f6752328db4a25c6fc41001121f0a160a14e6635e52a21ab22eaf27bdd036dd104b25d712c310eeabd2d4d1031ad2010abc011229122468747470733a2f2f626c6f636b636861696e2e696e666f2f712f6c6174657374686173681a01801237122868747470733a2f2f6170692d722e626974636f696e636861696e2e636f6d2f76312f7374617475731a0b8218778218676468617368124a122868747470733a2f2f6170692e626c6f636b63686169722e636f6d2f626974636f696e2f73746174731a1e83187782186664646174618218676f626573745f626c6f636b5f686173681a02100222060a020808100210e8071803200a280a301e3833408094ebdc0312720a4b0a490a473045022100dc671fb90cab42baa3a8e26bcd91da954b05299840539288624518ecc3b85140022033d6d65405ada2a72a1a55bb33577a76ef9ab320b58df96a4ce0ab498042620212230a2103f0acd97ec011b875376888b3538f70644e2ad537f61169e95b7c703176925d00\" , \"transaction\" : { \"DataRequest\" : { \"body\" : { \"dr_output\" : { \"collateral\" : 1000000000 , \"commit_and_reveal_fee\" : 10 , \"data_request\" : { \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"script\" : [ 128 ], \"url\" : \"https:\\/\\/blockchain.info\\/q\\/latesthash\" }, { \"kind\" : \"HTTP-GET\" , \"script\" : [ 130 , 24 , 119 , 130 , 24 , 103 , 100 , 104 , 97 , 115 , 104 ], \"url\" : \"https:\\/\\/api-r.bitcoinchain.com\\/v1\\/status\" } ], \"tally\" : { \"filters\" : [ { \"args\" : [], \"op\" : 8 } ], \"reducer\" : 2 }, \"time_lock\" : 0 }, \"min_consensus_percentage\" : 51 , \"witness_reward\" : 1000 , \"witnesses\" : 3 }, \"inputs\" : [ { \"output_pointer\" : \"1a79a8689f9ede624043993b620e6042d2b7e80573c19f6752328db4a25c6fc4:1\" } ], \"outputs\" : [ { \"address\" : \"twit1ue34u54zr2ezate8hhgrdhgsfvjawykr9kxtqq\" , \"time_lock\" : 0 , \"value\" : 124999996910 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 240 , 172 , 217 , 126 , 192 , 17 , 184 , 117 , 55 , 104 , 136 , 179 , 83 , 143 , 112 , 100 , 78 , 42 , 213 , 55 , 246 , 17 , 105 , 233 , 91 , 124 , 112 , 49 , 118 , 146 , 93 , 0 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 220 , 103 , 31 , 185 , 12 , 171 , 66 , 186 , 163 , 168 , 226 , 107 , 205 , 145 , 218 , 149 , 75 , 5 , 41 , 152 , 64 , 83 , 146 , 136 , 98 , 69 , 24 , 236 , 195 , 184 , 81 , 64 , 2 , 32 , 51 , 214 , 214 , 84 , 5 , 173 , 162 , 167 , 42 , 26 , 85 , 187 , 51 , 87 , 122 , 118 , 239 , 154 , 179 , 32 , 181 , 141 , 249 , 106 , 76 , 224 , 171 , 73 , 128 , 66 , 98 , 2 ] } } } ] } }, \"transaction_id\" : \"b7dbb6fdbf5f07ab6d0b037a9e2119d102172f372ffcdf4630122d1b2914ae02\" }, \"id\" : \"1\" } create_mnemonics \u00b6 The JsonRPC method create_mnemonics is used to generate a BIP39 mnemonic sentence that can be used to generate a new HD wallet . Request with parameters: length : number , indicating how many words the mnemonic sentence should have. Must be one of these: 12 , 15 , 18 , 21 or 24 . { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_mnemonics\" , \"params\" : { \"length\" : 12 }, \"id\" : 1 } Response: mnemonics : String , list of words of the mnemonic sentences. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"mnemonics\" : \"day voice lake monkey suit bread occur own cattle visit object ordinary\" }, \"id\" : 1 } create_vtt \u00b6 The method create_vtt is used to generate a Value Transfer Transaction (VTT) object. It will contain all required cryptographic information in order to be later broadcasted to a Witnet node (e.g. by using the method send_transaction ). Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . fee : number , miner fee in nanoWits. fee_type (optional): String , fee type chosen between weighted or absolute . Defaults to weighted if not inserted. label (optional): String , label to refer the vtt. outputs : Array , list of transaction outputs. address : String , the recipient address. amount : number , value to transfer in nanoWits. time_lock : number , indicates the epoch from which the data request could run before, before this epoch the request is ignored. utxo_strategy (optional): random | big_first | small_first , enum that allows to choose 3 different strategies for selecting which unspent transaction outputs are used as input of the VTT transaction. selected_utxos (optional): Array , array of selected output pointers to be spent. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_vtt\" , \"params\" : { \"session_id\" : \"7bbb8d1bec5419451fa57ae686de93d26e8d265b9328f5dc2f1e6e28acac4201\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"fee\" : 1 , \"label\" : \"\" , \"outputs\" : [ { \"address\" : \"twit1nfkythqds4r2hz3le2zaauxtl7yum76jd0ut9c\" , \"amount\" : 1000 , \"time_lock\" : 0 } ], \"utxo_strategy\" : \"random\" , \"selected_utxos\" : [ \"3a1ff5de49142d21280dc62dbdc02810a9665e9c23bb27b9094d6dbd6f4e527f:0\" , \"3cebaae8cc942056c475d7f9866a5de1be41aea0a1bcdb63edd533b9caef4043:0\" ] }, \"id\" : 1 } The create_vtt response will include all the information about the transaction: bytes : String , data request bytes represented in hexadecimal format. metadata : description of the outcome of the transaction, includes fee : number , miner fee in nanoWits. time_lock : number , indicates the epoch from which the funds will be available, before this epoch the funds are blocked. to : String , the address of the reciever. value : number , value that has been transferd in nanoWits. transaction : ValueTransfer , all transactional information regarding the created value transfer. body : Includes the inputs and outputs of the transaction. signatures : The signature of the transaction and the public key transaction_id : String , unique transaction identifier. Example of a create_vtt response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"bytes\" : \"0add010a670a280a260a220a204c4cc66b8bf7828797596ded89db7ddb1cd5b44dc18007738ef3d40e089a6add1001121a0a160a149a6c45dc0d8546ab8a3fca85def0cbff89cdfb521001121f0a160a1425e15594103fde1d9864807d091923ab648d6d1f10fec3d2d4d10312720a4b0a490a4730450221008e0c49acdcc92f63c6c71aa1ce7bb4d0524775c8e0af9d597d1b8bdfd8d2741e02201edd0d276786f7fcf319c4157501dca9c74457cac3b385a7475e6de85e1d826712230a2103f0acd97ec011b875376888b3538f70644e2ad537f61169e95b7c703176925d00\" , \"metadata\" : { \"fee\" : 1 , \"time_lock\" : 0 , \"to\" : \"wit1nfkythqds4r2hz3le2zaauxtl7yum76jr6409f\" , \"value\" : 1 }, \"transaction\" : { \"ValueTransfer\" : { \"body\" : { \"inputs\" : [ { \"output_pointer\" : \"4c4cc66b8bf7828797596ded89db7ddb1cd5b44dc18007738ef3d40e089a6add:1\" } ], \"outputs\" : [ { \"address\" : \"twit1nfkythqds4r2hz3le2zaauxtl7yum76jd0ut9c\" , \"time_lock\" : 0 , \"value\" : 1 }, { \"address\" : \"twit1yhs4t9qs8l0pmxrysp7sjxfr4djg6mgldk69zs\" , \"time_lock\" : 0 , \"value\" : 124999999998 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 240 , 172 , 217 , 126 , 192 , 17 , 184 , 117 , 55 , 104 , 136 , 179 , 83 , 143 , 112 , 100 , 78 , 42 , 213 , 55 , 246 , 17 , 105 , 233 , 91 , 124 , 112 , 49 , 118 , 146 , 93 , 0 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 142 , 12 , 73 , 172 , 220 , 201 , 47 , 99 , 198 , 199 , 26 , 161 , 206 , 123 , 180 , 208 , 82 , 71 , 117 , 200 , 224 , 175 , 157 , 89 , 125 , 27 , 139 , 223 , 216 , 210 , 116 , 30 , 2 , 32 , 30 , 221 , 13 , 39 , 103 , 134 , 247 , 252 , 243 , 25 , 196 , 21 , 117 , 1 , 220 , 169 , 199 , 68 , 87 , 202 , 195 , 179 , 133 , 167 , 71 , 94 , 109 , 232 , 94 , 29 , 130 , 103 ] } } } ] } }, \"transaction_id\" : \"66387166eba2d8af0b55bf309b9557ae812bdec0039fc45ece1f744ed309816f\" }, \"id\" : 18 } create_wallet \u00b6 The JsonRPC method create_wallet is used to generate a new Master Key for an empty HD wallet that is stored encrypted in the file system. Request with parameters: name (optional): String , human-friendly name for the wallet. description (optional): String , human-friendly caption for the wallet. seed_source : \"mnemonics\"|\"xprv\" , literal to identify if the seed source is of the type mnemonics or xprv and determine how the HD wallet master key will be generated from the data sent in the seedData parameter. seed_data : String , data used for generating the new HD wallet master key. password : String , password that will seed the key used to encrypt the wallet in the file system. The password must have at least eight characters. overwrite (optional): Boolean , in case that seed data was previously used for creating another wallet, this flag will overwrite the previous wallet with the new one. backup_password (optional): String , in case that seed source is \"xprv\" , seed_data must be decrypted with this parameter. birth_date (optional): current | imported (number) , data used to specify from which block number the wallet should start synchronizing (for importing wallets from a previously used seed phrase). { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_wallet\" , \"params\" : { \"name\" : \"Wallet #1\" , \"description\" : \"Personal use\" , \"seed_source\" : \"mnemonics\" , \"seed_data\" : \"exotic demand way fatigue skull poverty happy divide scrub seed jeans novel\" , \"password\" : \"12345678\" , \"overwrite\" : false , \"backup_password\" : null , \"birth_date\" : { \"imported\" : 10000 } }, \"id\" : 1 } Response: wallet_id : String , ID associated with the given wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : 1 } close_session \u00b6 The JsonRPC method close_session is used to close an active session without locking the currently unlocked wallet. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"close_session\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully closed. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" } delete_wallet \u00b6 The JsonRPC method delete_wallet is used to delete the wallet with the specified ID. It also removes the current active session. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"delete_wallet\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully deleted. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" } export_master_key \u00b6 The JsonRPC method export_master_key is used to export the master key of an existing wallet. This key is encrypted with a user-defined password using AES-CBC. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . password : String , user-defined password used to encrypt the key. { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_wallet\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"password\" : \"12345678\" }, \"id\" : 1 } Response: wallet_id : String , ID associated with the given wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : 1 } generate_address \u00b6 The JsonRPC method generate_address is used to derive deterministically a new external address for the given wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . external (optional): Boolean , if set to false it will generate an internal address. { \"jsonrpc\" : \"2.0\" , \"method\" : \"generate_address\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: address : String , address derived deterministically. path : String , derivation path used to generate the address. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"address\" : \"twit1gtvu9a37w9sxaej30grp9rpxkkwwjk3pq0jqf9\" , \"path\" : \"m/3'/4919'/0'/0/0\" }, \"id\" : \"1\" } get \u00b6 The method get allows to retrieve a previous stored key-value data in the wallet database. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . key : String , key under which the value will be stored. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get\" , \"params\" : { \"wallet_id\" : \"d5b53a4c40388a9be87acaf5a4dec9fd5c48f94913734bff88a08b18a618c76b\" , \"session_id\" : \"5982a279bbd201192f9d3685975c6cebb714ac32dea00cfea80e2013d510e35e\" , \"key\" : \"templates\" }, \"id\" : 1 } Response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"value\" : { \"name\" : \"object\" } }, \"id\" : 1 } get_addresses \u00b6 The JsonRPC method get_addresses is used to query for a list of previously derived addresses given a wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . offset (optional): number , initial position of the address list to be queried (by default is set to 0 ). limit (optional): number , size of the address list to be returned (by default is set to 25 ). external (optional): Boolean , if set to false it will get internal addresses. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_addresses\" , \"params\" : { \"session_id\" : \"9bcb54bf7494c21c29ef97256f6741b5b5bd5cb31d09d38e5ce98699010beea7\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"offset\" : 0 , \"limit\" : 25 }, \"id\" : \"1\" } Response with an array of addresses and additional related information: addresses : Array , list of queried addresses with additional information. account : number , identifies the current account in the session (the current version only supports the default account 0 ). address : String , address serialized in Bech32 format. index : number , sequential index used to derive address. info : String , additional information with balance movements and dates. first_payment_date : number , date of first received movement in UTC format (Coordinated Universal Time). label : String , user-defined label for this address. last_payment_date : number , date of last received movement in UTC format (Coordinated Universal Time). received_amount : number , total amount (in nanoWits) received by this address. received_payments : Array , list of Unspent Transaction Outputs (UTXOs) proving funds to this address. keychain : number , change value of the derivation path (See BIP-44 ). path : String , derivation path used to generate the address. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"addresses\" : [ { \"account\" : 0 , \"address\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4g8x2nn8\" , \"index\" : 0 , \"info\" : { \"first_payment_date\" : 1592476860 , \"label\" : null , \"last_payment_date\" : 1592476860 , \"received_amount\" : 125000000000 , \"received_payments\" : [ \"78bd0d8e4ef8ab67d4f18b357545f9dc73f63b7bf97a9a20c69b91b9e17ba985:1\" ] }, \"keychain\" : 0 , \"path\" : \"m/3'/4919'/0'/0/0\" , } ], \"total\" : 1 }, \"id\" : \"1\" } get_balance \u00b6 The JsonRPC method get_balance is used to query the current balance for a given wallet. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_balance\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response with different types of balances: local : number , amount of local pending movements not yet indexed in a block. unconfirmed : BalanceInfo , total amount of wallet's funds after last block, but not yet confirmed by a superblock. available : number , unconfirmed expendable funds. locked : number , unconfirmed time-locked funds. confirmed : BalanceInfo , total amount of wallet's funds after last confirmed superblock. available : number , confirmed expendable funds. locked : number , confirmed time-locked funds. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"confirmed\" : { \"available\" : 0 , \"locked\" : 0 }, \"local\" : 0 , \"unconfirmed\" : { \"available\" : 0 , \"locked\" : 0 } }, \"id\" : \"1\" } get_transactions \u00b6 The JsonRPC method get_transactions is used to query for a list of transactions given a wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . offset (optional): number , initial position of the transaction list to be queried (by default is set to 0 ). limit (optional): number , size of the transaction list to be returned (by default is set to 25 ). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_transactions\" , \"params\" : { \"session_id\" : \"9bcb54bf7494c21c29ef97256f6741b5b5bd5cb31d09d38e5ce98699010beea7\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"offset\" : 0 , \"limit\" : 25 }, \"id\" : \"1\" } Response with an array of transactions and additional related information: total : number , total amount of wallet transactions. transactions : Array , list of queried transactions with additional information. amount : number , transaction value. type : \"POSITIVE\"|\"NEGATIVE\" , type of balance movement in relation to the wallet. transaction : Transaction , additional transaction information. block : Block , information of block in which the transaction was included. block_hash : String , block hash in hexadecimal format. epoch : number block epoch. data : TransactionData , additional type-specific transaction data. The supported transaction types are value_transfer , data_request , tally , mint and commit . hash : String , transaction hash in hexadecimal format used as identifier. miner_fee : number , amount of nanoWits for the block miner. timestamp : number , transaction date in UTC format (Coordinated Universal Time). { \"jsonrpc\" : \"2.0\" , \"result\" : { \"total\" : 2 , \"transactions\" : [ { \"amount\" : 123 , \"transaction\" : { \"block\" : { \"block_hash\" : \"161fc079d3d7b8cd13af18bc615aaf24802bc1e64abd387d6d37be68c94fe8ec\" , \"epoch\" : 53555 }, \"data\" : { \"value_transfer\" : { \"inputs\" : [ { \"address\" : \"twit1r204scrl8djuljdn3gp8tgauzrl3x3c5dgl5wh\" , \"value\" : 125000000000 } ], \"outputs\" : [ { \"address\" : \"twit1yur5cmrz5vkc35p8fgg5c5la3yrl6yamwq02r6\" , \"time_lock\" : 0 , \"value\" : 123 }, { \"address\" : \"twit1r204scrl8djuljdn3gp8tgauzrl3x3c5dgl5wh\" , \"time_lock\" : 0 , \"value\" : 124999999865 } ] } }, \"hash\" : \"c2cf7cfce47f1645a97b199cac532496b5490fd1dd2d7b6da24818d964ff18ab\" , \"miner_fee\" : 12 , \"timestamp\" : 1595406375 }, \"type\" : \"POSITIVE\" } ] }, \"id\" : \"1\" } get_utxo_info \u00b6 The JsonRPC method get_utxo_info is used to query the current unspent transaction outputs for a given wallet. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_utxo_info\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response with a HashMap with all the information about the unspent transaction outputs of a specified wallet: output_info[] : HashMap , information related of all the unspent transaction outputs ( amount , pkh and time_lock ) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"3a1ff5de49142d21280dc62dbdc02810a9665e9c23bb27b9094d6dbd6f4e527f:0\" : { \"amount\" : \"10000000000\" , \"pkh\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\" , \"time_lock\" : \"0\" }, \"3cebaae8cc942056c475d7f9866a5de1be41aea0a1bcdb63edd533b9caef4043:0\" : { \"amount\" : \"10000000000\" , \"pkh\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\" , \"time_lock\" : \"0\" } }, \"id\" : \"1\" } get_wallet_infos \u00b6 The JsonRPC method get_wallet_infos displays the information about the wallet. This method has no parameters, as an example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_wallet_infos\" , \"id\" : \"1\" } Response: caption : String , human-friendly caption for the wallet. id : String , wallet ID. name : String , human-friendly name for the wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"infos\" : [ { \"caption\" : null , \"id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"name\" : null } ] }, \"id\" : \"1\" } lock_wallet \u00b6 The JsonRPC method lock_wallet is used to lock the wallet with the specified ID and close the active session. The decryption key for that wallet (hold in memory) is forgotten and the wallet server will be unable to update that wallet information until it is unlocked again. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"lock_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully locked. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" } refresh_session \u00b6 The JsonRPC method refresh_session is used to refresh an active session of a currently unlocked wallet. This call will reset the session expiration time for the given session. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"refresh_session\" , \"params\" : { \"session_id\" : \"b6166f88e5105740c34fc20f56dc6fcc2eaeb73de2a4884c4e4f4aa6957eb398\" }, \"id\" : 1 } Response: success : Boolean , reporting if the wallet was successfully refreshed. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" } resync_wallet \u00b6 The JsonRPC method resync_wallet is used to trigger a re-synchronization of the wallet with the specified ID. The wallet will reset all previously synchronized wallet data and it will index again all previous blockchain transactions. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"resync_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet has successfully re-synchronized. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" } rpc.off \u00b6 Use this method rpc.off to unsubscribe from previous subscriptions. Request with parameters: <data> : Array , subscription identifiers assigned when subscribing to wallet sessions. See rpc.on . { \"method\" : \"rpc.off\" , \"params\" : [ \"221794a024ddaee0b0a0e9cb6bfd8f00fed86855134d917255f3cfac3dc84f2b\" ], \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" } The response for a successful unsubscribe: { \"jsonrpc\" : \"2.0\" , \"result\" : null , \"id\" : \"1\" } rpc.on \u00b6 Use this method rpc.on to subscribe to update events related to your session wallets. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"method\" : \"rpc.on\" , \"params\" : { \"session_id\" : \"d4fe394eb9b82b4116f15d821bfb95cf1ddc912bc8fc1d6b2ab1f9c6e37269c4\" }, \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" } The response is: result : String , subscription identifier that can be used to unsubscribe from notifications. See rpc.off . { \"jsonrpc\" : \"2.0\" , \"result\" : \"221794a024ddaee0b0a0e9cb6bfd8f00fed86855134d917255f3cfac3dc84f2b\" , \"id\" : \"1\" } Here is an example of a block event sent out by a node: { \"jsonrpc\" : \"2.0\" , \"method\" : \"notifications\" , \"params\" : [ { \"events\" : [ { \"Block\" : { \"block_hash\" : \"eb44b8169b155896c323ab392430fe43efde4bd7c896a932c39dfa262738522d\" , \"epoch\" : 293566 } } ], \"status\" : { \"account\" : { \"balance\" : 0 , \"id\" : 0 }, \"node\" : { \"address\" : \"127.0.0.1:21338\" , \"last_beacon\" : { \"checkpoint\" : 293566 , \"hashPrevBlock\" : \"eb44b8169b155896c323ab392430fe43efde4bd7c896a932c39dfa262738522d\" }, \"network\" : \"Mainnet\" }, \"session\" : \"c8a58658d4d2785e407e77a3dc7e04ac05c5dc66ab76eb0e0d031642ea20e42a\" , \"wallet\" : { \"id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"last_sync\" : { \"checkpoint\" : 293565 , \"hashPrevBlock\" : \"44877f15997b2b791f0da65027c447bce4935554fbc46de449b2219ff5568973\" } } } } ] } run_rad_request \u00b6 The JsonRPC method run_rad_request is used to execute a RAD request in order to test it functionally before deploying it on the network. The request has as parameter a rad_request , which has itself as parameters: time_lock : number , indicates the epoch from which the data request could run before, before this epoch the request is ignored. retrieve : Array , is composed of a supported retrieve method, the url of the API from which get the data of the request, and the the bytes-serialized RADON script. aggregate : Aggregate , includes the operators needed to perform the aggregation from the retrieves. tally : Tally , includes the operators needed to perform the tally after the aggregation. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"run_rad_request\" , \"params\" : { \"rad_request\" : { \"time_lock\" : 0 , \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://csrng.net/csrng/csrng.php?min=0&max=100\" , \"script\" : [ 131 , 24 , 118 , 130 , 24 , 24 , 0 , 130 , 24 , 100 , 102 , 114 , 97 , 110 , 100 , 111 , 109 ] } ], \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"tally\" : { \"filters\" : [ { \"op\" : 8 , \"args\" : [] } ], \"reducer\" : 2 } } }, \"id\" : 1 } The response includes all the partial results of the request for the three different stages ( retrieve , aggregate and tally ). { \"jsonrpc\" : \"2.0\" , \"result\" : { \"result\" : { \"retrieve\" : [ { \"metadata\" : \"Retrieval\" , \"partial_results\" : [ { \"RadonString\" : \"[{\\\"status\\\":\\\"success\\\",\\\"min\\\":0,\\\"max\\\":100,\\\"random\\\":98}]\" }, { \"RadonArray\" : [ { \"RadonMap\" : { \"max\" : { \"RadonFloat\" : 100 }, \"min\" : { \"RadonFloat\" : 0 }, \"random\" : { \"RadonFloat\" : 98 }, \"status\" : { \"RadonString\" : \"success\" } } } ] }, { \"RadonMap\" : { \"max\" : { \"RadonFloat\" : 100 }, \"min\" : { \"RadonFloat\" : 0 }, \"random\" : { \"RadonFloat\" : 98 }, \"status\" : { \"RadonString\" : \"success\" } } }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 3303591 , \"secs\" : 0 } } ], \"aggregate\" : { \"metadata\" : \"Aggregation\" , \"partial_results\" : [ { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 148354 , \"secs\" : 0 } }, \"tally\" : { \"metadata\" : { \"Tally\" : { \"consensus\" : 1 , \"errors\" : [ false ], \"liars\" : [ false ] } }, \"partial_results\" : [ { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 214414 , \"secs\" : 0 } } } }, \"id\" : 1 } send_transaction \u00b6 The method send_transaction is used to broadcast a given transaction to the Witnet network. Apart from the wallet_id and session_id , it requires an already created transaction (e.g. by using the methods create_vtt ) or create_data_request ). The request requires the following parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . transaction : Transaction , serialized transaction object. It can be created by using the methods create_vtt ) or create_data_request . Example of a send_transaction for sending 500 nanoWits to an address. { \"jsonrpc\" : \"2.0\" , \"method\" : \"send_transaction\" , \"params\" : { \"wallet_id\" : \"92e724030ed4e0d9c8fafd0ed617e2f7fb08512a36d6e12d30a44a63117aad0d\" , \"session_id\" : \"4e373de7144dc08bc0a2b2efad52c902f4661453328523e42a02201c66716803\" , \"transaction\" : { \"ValueTransfer\" : { \"body\" : { \"inputs\" : [ { \"output_pointer\" : \"5d438cb68c5c24228f6c12d0bb33235159118230948410bfd1e41b7e239d944d:1\" } ], \"outputs\" : [ { \"address\" : \"twit1z8u6ruc4secs48x20qwstl80g8p9nkp3a33ts7\" , \"time_lock\" : 0 , \"value\" : 500 }, { \"address\" : \"twit15aetshda2t435xg965k70w5y5ra8x5kj78m39l\" , \"time_lock\" : 0 , \"value\" : 49470 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 216 , 133 , 176 , 114 , 224 , 176 , 158 , 76 , 90 , 139 , 124 , 204 , 254 , 172 , 133 , 198 , 205 , 208 , 230 , 93 , 215 , 92 , 47 , 195 , 175 , 136 , 164 , 40 , 81 , 166 , 143 , 83 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 238 , 241 , 230 , 193 , 168 , 58 , 205 , 87 , 171 , 157 , 12 , 135 , 233 , 221 , 65 , 131 , 187 , 192 , 197 , 31 , 245 , 202 , 88 , 142 , 137 , 124 , 135 , 28 , 190 , 159 , 190 , 246 , 2 , 32 , 42 , 20 , 65 , 244 , 88 , 251 , 91 , 131 , 13 , 68 , 10 , 82 , 194 , 250 , 36 , 181 , 109 , 200 , 113 , 112 , 237 , 209 , 43 , 212 , 74 , 247 , 128 , 30 , 80 , 111 , 251 , 192 ] } } } ] } } }, \"id\" : 1 } The response includes the JsonRPC response after sending the transaction to the node API and the balance movement that affects the wallet: balance_movement : BalanceMovement , the wallet balance movement, which is pending and has not yet been indexed into a block. jsonrpc_result : Bool , the result of sending the transaction to the node using the intentory JsonRPC API method. { \"jsonrpc\": \"2.0\", \"result\": { \"balance_movement\": { \"amount\": 1, \"transaction\": { \"block\": { \"block_hash\": \"0000000000000000000000000000000000000000000000000000000000000000\", \"epoch\": 0 }, \"confirmed\": false, \"data\": { \"value_transfer\": { \"inputs\": [], \"outputs\": [ { \"address\": \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\", \"time_lock\": 0, \"value\": 1 }, { \"address\": \"twit1ue34u54zr2ezate8hhgrdhgsfvjawykr9kxtqq\", \"time_lock\": 0, \"value\": 998 } ] } }, \"hash\": \"ddab6bee4c95800cca06b3d1e2fafd5f47b97e73f8b6725916ccac6be6537041\", \"miner_fee\": 0, \"timestamp\": 1601544326 }, \"type\": \"NEGATIVE\" }, \"jsonrpc_result\": true }, \"id\": 1 } set \u00b6 The method set allows to store key-value data in the wallet database. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . key : String , key under which the value will be stored. value : Object , JSON object to be stored. { \"jsonrpc\" : \"2.0\" , \"method\" : \"set\" , \"params\" : { \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"session_id\" : \"3cf194594d69c3b2b80a11f30953da96599dd2dd56cf72db838abba092cea3df\" , \"key\" : \"templates\" , \"value\" : { \"name\" : \"object\" } }, \"id\" : 1 } Response: { \"jsonrpc\" : \"2.0\" , \"result\" : null , \"id\" : 1 } shutdown \u00b6 To shutdown the wallet. It has no response, directly stops the wallet specified in the parameters. If no session_id is provided, wallet will be shutdown only if there are no open sessions. Request with parameters: session_id (optional): String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"shutdown\" , \"params\" : { \"session_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" }, \"id\" : \"1\" } sign_data \u00b6 This method uses the wallet's master key to sign message data. The parameters are: session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . wallet_id : String , the ID associated to the wallet. See get_wallet_infos . data : String , the data to be signed. extended_pk : Bool , if this flag is set to true, extended public key will be include ( chaincode ). If leaked, wallet public addresses might be derived. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"sign_data\" , \"params\" : { \"session_id\" : \"61078ed2685b82854b1d40b23e200994e80a04c2e2ba82e0e92c7adb9e348cad\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"data\" : \"data\" , \"extended_pk\" : true }, \"id\" : 1 } The response includes the parameters: chaincode : String , cryptographic material used to derive keys. public_key : String , the wallet's public key. signture : String , the signature. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"chaincode\" : \"c42185b347af99f7fbb4bf41f8ea1e9b1be70f1a4507f7cbe62e99f487af4af4\" , \"public_key\" : \"025aaf8c0fd8598a5486085900e1ffe464ef4241281a5fff80389235740d3f19d2\" , \"signature\" : \"30450221008fb3756fb3056df78cd43d0f2abe97a60c203eeb6d5e2180b9f7abad7ade375102207a488ae575abb88f1eaddfdbe72ad1c4738c62f8e96c448c5f7b1ad478199e5d\" }, \"id\" : 1 } unlock_wallet \u00b6 The JsonRPC method unlock_wallet is used to unlock the wallet with the specified identifier by providing a decryption key. This key will be hold in memory until the wallet is locked again. By default, sessions will expired after 1 hour. As long as a wallet is unlocked, you can operate it without having to supply the password again by just using the session ID, until it expires. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . password : String , the password that unlocks the wallet. { \"jsonrpc\" : \"2.0\" , \"method\" : \"unlock_wallet\" , \"params\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"password\" : \"12345678\" }, \"id\" : 1 } Response: session_id : number , generated identifier for the current wallet session. session_expiration_secs : number , amount of seconds after which the session will expire. account_balance : number , wallet's account balance in nano Wits. name : String , human-friendly name for the wallet. caption : String , human-friendly caption for the wallet. current_account : number , identifies the current active account in the session (the current version only supports the default account 0 ). available_accounts : Array , list of available accounts in the wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"account_balance\" : 0 , \"available_accounts\" : [ 0 ], \"caption\" : null , \"current_account\" : 0 , \"name\" : null , \"session_expiration_secs\" : 3200 , \"session_id\" : \"9c4f690a50de45b91bb4a5d7fc964c6853ca4eb29fa4ed3e2c9ddfd3e2da45e7\" }, \"id\" : 1 } update_wallet \u00b6 The JsonRPC method update_wallet is used to update the name and/or caption of an existing wallet. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . name : String , wallet name shown in get_wallet_infos . description : String , wallet private description (only available for authenticated clients after unlock_wallet ). { \"jsonrpc\" : \"2.0\" , \"method\" : \"update_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"name\" : \"New Name\" , \"description\" : \"New Description\" }, \"id\" : 1 } Response: success : Boolean , reporting if the wallet's update was successfull. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : 1 } validate_mnemonics \u00b6 The JsonRPC method validate_mnemonics is used to verify that validity of the seed source that might be used to generate a new wallet. Request with parameters: seed_source : \"mnemonics\"|\"xprv\" , literal to identify if the seed source is of the type mnemonics or xprv . seed_data : String , containing the used seed data, either a list of mnemonic words or a xprv . backup_password (optional): String , in case that seed source is \"xprv\" , seed_data must be decrypted with this parameter. { \"jsonrpc\" : \"2.0\" , \"method\" : \"validate_mnemonics\" , \"params\" : { \"seed_source\" : \"mnemonics\" , \"seed_data\" : \"day voice lake monkey suit bread occur own cattle visit object ordinary\" }, \"id\" : 1 } Response: valid : Boolean , true if valid seed in form of mnemonics or xprv . { \"jsonrpc\" : \"2.0\" , \"result\" : { \"exist\" : false , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , }, \"id\" : 1 }","title":"Wallet API"},{"location":"developer/wallet-api/#wallet-server-api","text":"The wallet exposes a JSON-RPC API over Websocket by default at the URL 127.0.0.1:21338 . It can be set in the Witnet configuration file as follows: [wallet] node_url = \"127.0.0.1:21338\"","title":"Wallet Server API"},{"location":"developer/wallet-api/#summary","text":"Method Name Request Params Response close_session session_id success create_data_request session_id , wallet_id , request , fee , ( fee_type ) bytes , transaction , transaction_id create_mnemonics length mnemonics create_vtt session_id , wallet_id , fee , ( fee_type ), [ address , value , ( time_lock )], ( utxo_strategy ), ( selected_utxos ) bytes , metadata , transaction , transaction_id create_wallet ( name ), ( description ), seed_source , seed_data , password , ( overwrite ), ( backup_password ), ( birth_date ) wallet_id delete_wallet session_id , wallet_id success export_master_key session_id , wallet_id , password private_key generate_address session_id , wallet_id , ( external ) address , path get session_id , wallet_id , key value get_addresses session_id , wallet_id , ( offset ), ( limit ), ( external ) address[] , total get_balance session_id , wallet_id confirmed , local , unconfirmed get_transactions session_id , wallet_id , ( offset ), ( limit ) transactions[] , total get_utxo_info session_id , wallet_id output_info[] get_wallet_infos (none) wallet_info[] lock_wallet session_id , wallet_id success refresh_session session_id success resync_wallet session_id , wallet_id success rpc.off ( subscription_id[] ) (none) rpc.on session_id ( subscription_id ) run_rad_request request result send_transaction session_id , wallet_id , transaction balance_movement , jsonrpc_result set session_id , wallet_id , key , value (none) shutdown session_id (none) sign_data session_id , wallet_id , data , extended_pk chaincode , public_key , signature unlock_wallet wallet_id , password session_id , session_expiration_secs , ... update_wallet session_id , wallet_id , ( name ), ( description ) success validate_mnemonics seed_source , seed_data , ( backup_password ) exist , wallet_id","title":"Summary"},{"location":"developer/wallet-api/#wallet-api-endpoints","text":"","title":"Wallet API Endpoints"},{"location":"developer/wallet-api/#create_data_request","text":"The method create_data_request creates a data request transaction object. It contains all required cryptographic information in order to be later sent to a Witnet node (e.g. by using the method send_transaction ). Request with parameters: session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . wallet_id : String , the ID associated to the wallet. See get_wallet_infos . fee : number , amount in nanoWitswill be earned by the miner that publishes the request. fee_type : (optional) String , fee type chosen between weighted or absolute . Defaults to weighted if not inserted. request : DataRequestOutput , a struct with required data request fields. data_request : RADRequest , data request with CBOR codification. witness_reward : number , reward in nanoWits to the witnesses of the data request. witnesses : number , minimum number of witnet nodes that must perform the request. commit_and_reveal_fee : number , amount in nanoWits that will be earned by the miner for each each valid commitment and reveal transaction. min_consensus_percentage : number , , minimum of consensus required to consider the request as valid. collateral : number , collateral amount in nanoWits. More information about the parameters can be found in the tutorial of data request parameters fine-tuning . As an example, this data request created a data request that retrives the last Bitcoin blockhash from two different sources using three witnesses: { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_data_request\" , \"id\" : \"1\" , \"params\" : { \"session_id\" : \"678f4320d8f8ff1a9f86f56f20f0c6a76fba92db0e8e5b1fd2f21092de985f3e\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"request\" : { \"data_request\" : { \"time_lock\" : 0 , \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://blockchain.info/q/latesthash\" , \"script\" : [ 128 ] }, { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://api-r.bitcoinchain.com/v1/status\" , \"script\" : [ 130 , 24 , 119 , 130 , 24 , 103 , 100 , 104 , 97 , 115 , 104 ] } ], \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"tally\" : { \"filters\" : [ { \"op\" : 8 , \"args\" : [] } ], \"reducer\" : 2 } }, \"witness_reward\" : 1000 , \"witnesses\" : 3 , \"commit_and_reveal_fee\" : 10 , \"min_consensus_percentage\" : 51 , \"collateral\" : 1000000000 }, \"fee\" : 0 } } The create_data_request response will include the following data: bytes : String , data request bytes represented in hexadecimal format. transaction : DataRequest , all transactional information regarding the created data request. body : Includes the data request output, inputs and outputs of the transaction. signatures : The signature of the transaction and the public key transaction_id : String , unique transaction identifier. Example of a create_data_request response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"bytes\" : \"1297030aa0020a280a260a220a201a79a8689f9ede624043993b620e6042d2b7e80573c19f6752328db4a25c6fc41001121f0a160a14e6635e52a21ab22eaf27bdd036dd104b25d712c310eeabd2d4d1031ad2010abc011229122468747470733a2f2f626c6f636b636861696e2e696e666f2f712f6c6174657374686173681a01801237122868747470733a2f2f6170692d722e626974636f696e636861696e2e636f6d2f76312f7374617475731a0b8218778218676468617368124a122868747470733a2f2f6170692e626c6f636b63686169722e636f6d2f626974636f696e2f73746174731a1e83187782186664646174618218676f626573745f626c6f636b5f686173681a02100222060a020808100210e8071803200a280a301e3833408094ebdc0312720a4b0a490a473045022100dc671fb90cab42baa3a8e26bcd91da954b05299840539288624518ecc3b85140022033d6d65405ada2a72a1a55bb33577a76ef9ab320b58df96a4ce0ab498042620212230a2103f0acd97ec011b875376888b3538f70644e2ad537f61169e95b7c703176925d00\" , \"transaction\" : { \"DataRequest\" : { \"body\" : { \"dr_output\" : { \"collateral\" : 1000000000 , \"commit_and_reveal_fee\" : 10 , \"data_request\" : { \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"script\" : [ 128 ], \"url\" : \"https:\\/\\/blockchain.info\\/q\\/latesthash\" }, { \"kind\" : \"HTTP-GET\" , \"script\" : [ 130 , 24 , 119 , 130 , 24 , 103 , 100 , 104 , 97 , 115 , 104 ], \"url\" : \"https:\\/\\/api-r.bitcoinchain.com\\/v1\\/status\" } ], \"tally\" : { \"filters\" : [ { \"args\" : [], \"op\" : 8 } ], \"reducer\" : 2 }, \"time_lock\" : 0 }, \"min_consensus_percentage\" : 51 , \"witness_reward\" : 1000 , \"witnesses\" : 3 }, \"inputs\" : [ { \"output_pointer\" : \"1a79a8689f9ede624043993b620e6042d2b7e80573c19f6752328db4a25c6fc4:1\" } ], \"outputs\" : [ { \"address\" : \"twit1ue34u54zr2ezate8hhgrdhgsfvjawykr9kxtqq\" , \"time_lock\" : 0 , \"value\" : 124999996910 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 240 , 172 , 217 , 126 , 192 , 17 , 184 , 117 , 55 , 104 , 136 , 179 , 83 , 143 , 112 , 100 , 78 , 42 , 213 , 55 , 246 , 17 , 105 , 233 , 91 , 124 , 112 , 49 , 118 , 146 , 93 , 0 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 220 , 103 , 31 , 185 , 12 , 171 , 66 , 186 , 163 , 168 , 226 , 107 , 205 , 145 , 218 , 149 , 75 , 5 , 41 , 152 , 64 , 83 , 146 , 136 , 98 , 69 , 24 , 236 , 195 , 184 , 81 , 64 , 2 , 32 , 51 , 214 , 214 , 84 , 5 , 173 , 162 , 167 , 42 , 26 , 85 , 187 , 51 , 87 , 122 , 118 , 239 , 154 , 179 , 32 , 181 , 141 , 249 , 106 , 76 , 224 , 171 , 73 , 128 , 66 , 98 , 2 ] } } } ] } }, \"transaction_id\" : \"b7dbb6fdbf5f07ab6d0b037a9e2119d102172f372ffcdf4630122d1b2914ae02\" }, \"id\" : \"1\" }","title":"create_data_request"},{"location":"developer/wallet-api/#create_mnemonics","text":"The JsonRPC method create_mnemonics is used to generate a BIP39 mnemonic sentence that can be used to generate a new HD wallet . Request with parameters: length : number , indicating how many words the mnemonic sentence should have. Must be one of these: 12 , 15 , 18 , 21 or 24 . { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_mnemonics\" , \"params\" : { \"length\" : 12 }, \"id\" : 1 } Response: mnemonics : String , list of words of the mnemonic sentences. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"mnemonics\" : \"day voice lake monkey suit bread occur own cattle visit object ordinary\" }, \"id\" : 1 }","title":"create_mnemonics"},{"location":"developer/wallet-api/#create_vtt","text":"The method create_vtt is used to generate a Value Transfer Transaction (VTT) object. It will contain all required cryptographic information in order to be later broadcasted to a Witnet node (e.g. by using the method send_transaction ). Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . fee : number , miner fee in nanoWits. fee_type (optional): String , fee type chosen between weighted or absolute . Defaults to weighted if not inserted. label (optional): String , label to refer the vtt. outputs : Array , list of transaction outputs. address : String , the recipient address. amount : number , value to transfer in nanoWits. time_lock : number , indicates the epoch from which the data request could run before, before this epoch the request is ignored. utxo_strategy (optional): random | big_first | small_first , enum that allows to choose 3 different strategies for selecting which unspent transaction outputs are used as input of the VTT transaction. selected_utxos (optional): Array , array of selected output pointers to be spent. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_vtt\" , \"params\" : { \"session_id\" : \"7bbb8d1bec5419451fa57ae686de93d26e8d265b9328f5dc2f1e6e28acac4201\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"fee\" : 1 , \"label\" : \"\" , \"outputs\" : [ { \"address\" : \"twit1nfkythqds4r2hz3le2zaauxtl7yum76jd0ut9c\" , \"amount\" : 1000 , \"time_lock\" : 0 } ], \"utxo_strategy\" : \"random\" , \"selected_utxos\" : [ \"3a1ff5de49142d21280dc62dbdc02810a9665e9c23bb27b9094d6dbd6f4e527f:0\" , \"3cebaae8cc942056c475d7f9866a5de1be41aea0a1bcdb63edd533b9caef4043:0\" ] }, \"id\" : 1 } The create_vtt response will include all the information about the transaction: bytes : String , data request bytes represented in hexadecimal format. metadata : description of the outcome of the transaction, includes fee : number , miner fee in nanoWits. time_lock : number , indicates the epoch from which the funds will be available, before this epoch the funds are blocked. to : String , the address of the reciever. value : number , value that has been transferd in nanoWits. transaction : ValueTransfer , all transactional information regarding the created value transfer. body : Includes the inputs and outputs of the transaction. signatures : The signature of the transaction and the public key transaction_id : String , unique transaction identifier. Example of a create_vtt response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"bytes\" : \"0add010a670a280a260a220a204c4cc66b8bf7828797596ded89db7ddb1cd5b44dc18007738ef3d40e089a6add1001121a0a160a149a6c45dc0d8546ab8a3fca85def0cbff89cdfb521001121f0a160a1425e15594103fde1d9864807d091923ab648d6d1f10fec3d2d4d10312720a4b0a490a4730450221008e0c49acdcc92f63c6c71aa1ce7bb4d0524775c8e0af9d597d1b8bdfd8d2741e02201edd0d276786f7fcf319c4157501dca9c74457cac3b385a7475e6de85e1d826712230a2103f0acd97ec011b875376888b3538f70644e2ad537f61169e95b7c703176925d00\" , \"metadata\" : { \"fee\" : 1 , \"time_lock\" : 0 , \"to\" : \"wit1nfkythqds4r2hz3le2zaauxtl7yum76jr6409f\" , \"value\" : 1 }, \"transaction\" : { \"ValueTransfer\" : { \"body\" : { \"inputs\" : [ { \"output_pointer\" : \"4c4cc66b8bf7828797596ded89db7ddb1cd5b44dc18007738ef3d40e089a6add:1\" } ], \"outputs\" : [ { \"address\" : \"twit1nfkythqds4r2hz3le2zaauxtl7yum76jd0ut9c\" , \"time_lock\" : 0 , \"value\" : 1 }, { \"address\" : \"twit1yhs4t9qs8l0pmxrysp7sjxfr4djg6mgldk69zs\" , \"time_lock\" : 0 , \"value\" : 124999999998 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 240 , 172 , 217 , 126 , 192 , 17 , 184 , 117 , 55 , 104 , 136 , 179 , 83 , 143 , 112 , 100 , 78 , 42 , 213 , 55 , 246 , 17 , 105 , 233 , 91 , 124 , 112 , 49 , 118 , 146 , 93 , 0 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 142 , 12 , 73 , 172 , 220 , 201 , 47 , 99 , 198 , 199 , 26 , 161 , 206 , 123 , 180 , 208 , 82 , 71 , 117 , 200 , 224 , 175 , 157 , 89 , 125 , 27 , 139 , 223 , 216 , 210 , 116 , 30 , 2 , 32 , 30 , 221 , 13 , 39 , 103 , 134 , 247 , 252 , 243 , 25 , 196 , 21 , 117 , 1 , 220 , 169 , 199 , 68 , 87 , 202 , 195 , 179 , 133 , 167 , 71 , 94 , 109 , 232 , 94 , 29 , 130 , 103 ] } } } ] } }, \"transaction_id\" : \"66387166eba2d8af0b55bf309b9557ae812bdec0039fc45ece1f744ed309816f\" }, \"id\" : 18 }","title":"create_vtt"},{"location":"developer/wallet-api/#create_wallet","text":"The JsonRPC method create_wallet is used to generate a new Master Key for an empty HD wallet that is stored encrypted in the file system. Request with parameters: name (optional): String , human-friendly name for the wallet. description (optional): String , human-friendly caption for the wallet. seed_source : \"mnemonics\"|\"xprv\" , literal to identify if the seed source is of the type mnemonics or xprv and determine how the HD wallet master key will be generated from the data sent in the seedData parameter. seed_data : String , data used for generating the new HD wallet master key. password : String , password that will seed the key used to encrypt the wallet in the file system. The password must have at least eight characters. overwrite (optional): Boolean , in case that seed data was previously used for creating another wallet, this flag will overwrite the previous wallet with the new one. backup_password (optional): String , in case that seed source is \"xprv\" , seed_data must be decrypted with this parameter. birth_date (optional): current | imported (number) , data used to specify from which block number the wallet should start synchronizing (for importing wallets from a previously used seed phrase). { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_wallet\" , \"params\" : { \"name\" : \"Wallet #1\" , \"description\" : \"Personal use\" , \"seed_source\" : \"mnemonics\" , \"seed_data\" : \"exotic demand way fatigue skull poverty happy divide scrub seed jeans novel\" , \"password\" : \"12345678\" , \"overwrite\" : false , \"backup_password\" : null , \"birth_date\" : { \"imported\" : 10000 } }, \"id\" : 1 } Response: wallet_id : String , ID associated with the given wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : 1 }","title":"create_wallet"},{"location":"developer/wallet-api/#close_session","text":"The JsonRPC method close_session is used to close an active session without locking the currently unlocked wallet. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"close_session\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully closed. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" }","title":"close_session"},{"location":"developer/wallet-api/#delete_wallet","text":"The JsonRPC method delete_wallet is used to delete the wallet with the specified ID. It also removes the current active session. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"delete_wallet\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully deleted. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" }","title":"delete_wallet"},{"location":"developer/wallet-api/#export_master_key","text":"The JsonRPC method export_master_key is used to export the master key of an existing wallet. This key is encrypted with a user-defined password using AES-CBC. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . password : String , user-defined password used to encrypt the key. { \"jsonrpc\" : \"2.0\" , \"method\" : \"create_wallet\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"password\" : \"12345678\" }, \"id\" : 1 } Response: wallet_id : String , ID associated with the given wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : 1 }","title":"export_master_key"},{"location":"developer/wallet-api/#generate_address","text":"The JsonRPC method generate_address is used to derive deterministically a new external address for the given wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . external (optional): Boolean , if set to false it will generate an internal address. { \"jsonrpc\" : \"2.0\" , \"method\" : \"generate_address\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: address : String , address derived deterministically. path : String , derivation path used to generate the address. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"address\" : \"twit1gtvu9a37w9sxaej30grp9rpxkkwwjk3pq0jqf9\" , \"path\" : \"m/3'/4919'/0'/0/0\" }, \"id\" : \"1\" }","title":"generate_address"},{"location":"developer/wallet-api/#get","text":"The method get allows to retrieve a previous stored key-value data in the wallet database. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . key : String , key under which the value will be stored. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get\" , \"params\" : { \"wallet_id\" : \"d5b53a4c40388a9be87acaf5a4dec9fd5c48f94913734bff88a08b18a618c76b\" , \"session_id\" : \"5982a279bbd201192f9d3685975c6cebb714ac32dea00cfea80e2013d510e35e\" , \"key\" : \"templates\" }, \"id\" : 1 } Response: { \"jsonrpc\" : \"2.0\" , \"result\" : { \"value\" : { \"name\" : \"object\" } }, \"id\" : 1 }","title":"get"},{"location":"developer/wallet-api/#get_addresses","text":"The JsonRPC method get_addresses is used to query for a list of previously derived addresses given a wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . offset (optional): number , initial position of the address list to be queried (by default is set to 0 ). limit (optional): number , size of the address list to be returned (by default is set to 25 ). external (optional): Boolean , if set to false it will get internal addresses. { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_addresses\" , \"params\" : { \"session_id\" : \"9bcb54bf7494c21c29ef97256f6741b5b5bd5cb31d09d38e5ce98699010beea7\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"offset\" : 0 , \"limit\" : 25 }, \"id\" : \"1\" } Response with an array of addresses and additional related information: addresses : Array , list of queried addresses with additional information. account : number , identifies the current account in the session (the current version only supports the default account 0 ). address : String , address serialized in Bech32 format. index : number , sequential index used to derive address. info : String , additional information with balance movements and dates. first_payment_date : number , date of first received movement in UTC format (Coordinated Universal Time). label : String , user-defined label for this address. last_payment_date : number , date of last received movement in UTC format (Coordinated Universal Time). received_amount : number , total amount (in nanoWits) received by this address. received_payments : Array , list of Unspent Transaction Outputs (UTXOs) proving funds to this address. keychain : number , change value of the derivation path (See BIP-44 ). path : String , derivation path used to generate the address. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"addresses\" : [ { \"account\" : 0 , \"address\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4g8x2nn8\" , \"index\" : 0 , \"info\" : { \"first_payment_date\" : 1592476860 , \"label\" : null , \"last_payment_date\" : 1592476860 , \"received_amount\" : 125000000000 , \"received_payments\" : [ \"78bd0d8e4ef8ab67d4f18b357545f9dc73f63b7bf97a9a20c69b91b9e17ba985:1\" ] }, \"keychain\" : 0 , \"path\" : \"m/3'/4919'/0'/0/0\" , } ], \"total\" : 1 }, \"id\" : \"1\" }","title":"get_addresses"},{"location":"developer/wallet-api/#get_balance","text":"The JsonRPC method get_balance is used to query the current balance for a given wallet. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_balance\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response with different types of balances: local : number , amount of local pending movements not yet indexed in a block. unconfirmed : BalanceInfo , total amount of wallet's funds after last block, but not yet confirmed by a superblock. available : number , unconfirmed expendable funds. locked : number , unconfirmed time-locked funds. confirmed : BalanceInfo , total amount of wallet's funds after last confirmed superblock. available : number , confirmed expendable funds. locked : number , confirmed time-locked funds. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"confirmed\" : { \"available\" : 0 , \"locked\" : 0 }, \"local\" : 0 , \"unconfirmed\" : { \"available\" : 0 , \"locked\" : 0 } }, \"id\" : \"1\" }","title":"get_balance"},{"location":"developer/wallet-api/#get_transactions","text":"The JsonRPC method get_transactions is used to query for a list of transactions given a wallet and session ID. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . offset (optional): number , initial position of the transaction list to be queried (by default is set to 0 ). limit (optional): number , size of the transaction list to be returned (by default is set to 25 ). { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_transactions\" , \"params\" : { \"session_id\" : \"9bcb54bf7494c21c29ef97256f6741b5b5bd5cb31d09d38e5ce98699010beea7\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"offset\" : 0 , \"limit\" : 25 }, \"id\" : \"1\" } Response with an array of transactions and additional related information: total : number , total amount of wallet transactions. transactions : Array , list of queried transactions with additional information. amount : number , transaction value. type : \"POSITIVE\"|\"NEGATIVE\" , type of balance movement in relation to the wallet. transaction : Transaction , additional transaction information. block : Block , information of block in which the transaction was included. block_hash : String , block hash in hexadecimal format. epoch : number block epoch. data : TransactionData , additional type-specific transaction data. The supported transaction types are value_transfer , data_request , tally , mint and commit . hash : String , transaction hash in hexadecimal format used as identifier. miner_fee : number , amount of nanoWits for the block miner. timestamp : number , transaction date in UTC format (Coordinated Universal Time). { \"jsonrpc\" : \"2.0\" , \"result\" : { \"total\" : 2 , \"transactions\" : [ { \"amount\" : 123 , \"transaction\" : { \"block\" : { \"block_hash\" : \"161fc079d3d7b8cd13af18bc615aaf24802bc1e64abd387d6d37be68c94fe8ec\" , \"epoch\" : 53555 }, \"data\" : { \"value_transfer\" : { \"inputs\" : [ { \"address\" : \"twit1r204scrl8djuljdn3gp8tgauzrl3x3c5dgl5wh\" , \"value\" : 125000000000 } ], \"outputs\" : [ { \"address\" : \"twit1yur5cmrz5vkc35p8fgg5c5la3yrl6yamwq02r6\" , \"time_lock\" : 0 , \"value\" : 123 }, { \"address\" : \"twit1r204scrl8djuljdn3gp8tgauzrl3x3c5dgl5wh\" , \"time_lock\" : 0 , \"value\" : 124999999865 } ] } }, \"hash\" : \"c2cf7cfce47f1645a97b199cac532496b5490fd1dd2d7b6da24818d964ff18ab\" , \"miner_fee\" : 12 , \"timestamp\" : 1595406375 }, \"type\" : \"POSITIVE\" } ] }, \"id\" : \"1\" }","title":"get_transactions"},{"location":"developer/wallet-api/#get_utxo_info","text":"The JsonRPC method get_utxo_info is used to query the current unspent transaction outputs for a given wallet. Request with parameters: session_id : String , session ID assigned to you when you unlocked the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_utxo_info\" , \"params\" : { \"session_id\" : \"9fa1d779afea88a29768dd05647e37b2f64fc103c1081b0ee9e62fb283f5cd02\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response with a HashMap with all the information about the unspent transaction outputs of a specified wallet: output_info[] : HashMap , information related of all the unspent transaction outputs ( amount , pkh and time_lock ) { \"jsonrpc\" : \"2.0\" , \"result\" : { \"3a1ff5de49142d21280dc62dbdc02810a9665e9c23bb27b9094d6dbd6f4e527f:0\" : { \"amount\" : \"10000000000\" , \"pkh\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\" , \"time_lock\" : \"0\" }, \"3cebaae8cc942056c475d7f9866a5de1be41aea0a1bcdb63edd533b9caef4043:0\" : { \"amount\" : \"10000000000\" , \"pkh\" : \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\" , \"time_lock\" : \"0\" } }, \"id\" : \"1\" }","title":"get_utxo_info"},{"location":"developer/wallet-api/#get_wallet_infos","text":"The JsonRPC method get_wallet_infos displays the information about the wallet. This method has no parameters, as an example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"get_wallet_infos\" , \"id\" : \"1\" } Response: caption : String , human-friendly caption for the wallet. id : String , wallet ID. name : String , human-friendly name for the wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"infos\" : [ { \"caption\" : null , \"id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"name\" : null } ] }, \"id\" : \"1\" }","title":"get_wallet_infos"},{"location":"developer/wallet-api/#lock_wallet","text":"The JsonRPC method lock_wallet is used to lock the wallet with the specified ID and close the active session. The decryption key for that wallet (hold in memory) is forgotten and the wallet server will be unable to update that wallet information until it is unlocked again. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"lock_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet was successfully locked. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" }","title":"lock_wallet"},{"location":"developer/wallet-api/#refresh_session","text":"The JsonRPC method refresh_session is used to refresh an active session of a currently unlocked wallet. This call will reset the session expiration time for the given session. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"refresh_session\" , \"params\" : { \"session_id\" : \"b6166f88e5105740c34fc20f56dc6fcc2eaeb73de2a4884c4e4f4aa6957eb398\" }, \"id\" : 1 } Response: success : Boolean , reporting if the wallet was successfully refreshed. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" }","title":"refresh_session"},{"location":"developer/wallet-api/#resync_wallet","text":"The JsonRPC method resync_wallet is used to trigger a re-synchronization of the wallet with the specified ID. The wallet will reset all previously synchronized wallet data and it will index again all previous blockchain transactions. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . wallet_id : String , ID associated to the wallet. See get_wallet_infos . { \"jsonrpc\" : \"2.0\" , \"method\" : \"resync_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" }, \"id\" : \"1\" } Response: success : Boolean , reporting if the wallet has successfully re-synchronized. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : \"1\" }","title":"resync_wallet"},{"location":"developer/wallet-api/#rpcoff","text":"Use this method rpc.off to unsubscribe from previous subscriptions. Request with parameters: <data> : Array , subscription identifiers assigned when subscribing to wallet sessions. See rpc.on . { \"method\" : \"rpc.off\" , \"params\" : [ \"221794a024ddaee0b0a0e9cb6bfd8f00fed86855134d917255f3cfac3dc84f2b\" ], \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" } The response for a successful unsubscribe: { \"jsonrpc\" : \"2.0\" , \"result\" : null , \"id\" : \"1\" }","title":"rpc.off"},{"location":"developer/wallet-api/#rpcon","text":"Use this method rpc.on to subscribe to update events related to your session wallets. Request with parameters: session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"method\" : \"rpc.on\" , \"params\" : { \"session_id\" : \"d4fe394eb9b82b4116f15d821bfb95cf1ddc912bc8fc1d6b2ab1f9c6e37269c4\" }, \"id\" : \"1\" , \"jsonrpc\" : \"2.0\" } The response is: result : String , subscription identifier that can be used to unsubscribe from notifications. See rpc.off . { \"jsonrpc\" : \"2.0\" , \"result\" : \"221794a024ddaee0b0a0e9cb6bfd8f00fed86855134d917255f3cfac3dc84f2b\" , \"id\" : \"1\" } Here is an example of a block event sent out by a node: { \"jsonrpc\" : \"2.0\" , \"method\" : \"notifications\" , \"params\" : [ { \"events\" : [ { \"Block\" : { \"block_hash\" : \"eb44b8169b155896c323ab392430fe43efde4bd7c896a932c39dfa262738522d\" , \"epoch\" : 293566 } } ], \"status\" : { \"account\" : { \"balance\" : 0 , \"id\" : 0 }, \"node\" : { \"address\" : \"127.0.0.1:21338\" , \"last_beacon\" : { \"checkpoint\" : 293566 , \"hashPrevBlock\" : \"eb44b8169b155896c323ab392430fe43efde4bd7c896a932c39dfa262738522d\" }, \"network\" : \"Mainnet\" }, \"session\" : \"c8a58658d4d2785e407e77a3dc7e04ac05c5dc66ab76eb0e0d031642ea20e42a\" , \"wallet\" : { \"id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"last_sync\" : { \"checkpoint\" : 293565 , \"hashPrevBlock\" : \"44877f15997b2b791f0da65027c447bce4935554fbc46de449b2219ff5568973\" } } } } ] }","title":"rpc.on"},{"location":"developer/wallet-api/#run_rad_request","text":"The JsonRPC method run_rad_request is used to execute a RAD request in order to test it functionally before deploying it on the network. The request has as parameter a rad_request , which has itself as parameters: time_lock : number , indicates the epoch from which the data request could run before, before this epoch the request is ignored. retrieve : Array , is composed of a supported retrieve method, the url of the API from which get the data of the request, and the the bytes-serialized RADON script. aggregate : Aggregate , includes the operators needed to perform the aggregation from the retrieves. tally : Tally , includes the operators needed to perform the tally after the aggregation. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"run_rad_request\" , \"params\" : { \"rad_request\" : { \"time_lock\" : 0 , \"retrieve\" : [ { \"kind\" : \"HTTP-GET\" , \"url\" : \"https://csrng.net/csrng/csrng.php?min=0&max=100\" , \"script\" : [ 131 , 24 , 118 , 130 , 24 , 24 , 0 , 130 , 24 , 100 , 102 , 114 , 97 , 110 , 100 , 111 , 109 ] } ], \"aggregate\" : { \"filters\" : [], \"reducer\" : 2 }, \"tally\" : { \"filters\" : [ { \"op\" : 8 , \"args\" : [] } ], \"reducer\" : 2 } } }, \"id\" : 1 } The response includes all the partial results of the request for the three different stages ( retrieve , aggregate and tally ). { \"jsonrpc\" : \"2.0\" , \"result\" : { \"result\" : { \"retrieve\" : [ { \"metadata\" : \"Retrieval\" , \"partial_results\" : [ { \"RadonString\" : \"[{\\\"status\\\":\\\"success\\\",\\\"min\\\":0,\\\"max\\\":100,\\\"random\\\":98}]\" }, { \"RadonArray\" : [ { \"RadonMap\" : { \"max\" : { \"RadonFloat\" : 100 }, \"min\" : { \"RadonFloat\" : 0 }, \"random\" : { \"RadonFloat\" : 98 }, \"status\" : { \"RadonString\" : \"success\" } } } ] }, { \"RadonMap\" : { \"max\" : { \"RadonFloat\" : 100 }, \"min\" : { \"RadonFloat\" : 0 }, \"random\" : { \"RadonFloat\" : 98 }, \"status\" : { \"RadonString\" : \"success\" } } }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 3303591 , \"secs\" : 0 } } ], \"aggregate\" : { \"metadata\" : \"Aggregation\" , \"partial_results\" : [ { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 148354 , \"secs\" : 0 } }, \"tally\" : { \"metadata\" : { \"Tally\" : { \"consensus\" : 1 , \"errors\" : [ false ], \"liars\" : [ false ] } }, \"partial_results\" : [ { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonArray\" : [ { \"RadonFloat\" : 98 } ] }, { \"RadonFloat\" : 98 } ], \"result\" : { \"RadonFloat\" : 98 }, \"running_time\" : { \"nanos\" : 214414 , \"secs\" : 0 } } } }, \"id\" : 1 }","title":"run_rad_request"},{"location":"developer/wallet-api/#send_transaction","text":"The method send_transaction is used to broadcast a given transaction to the Witnet network. Apart from the wallet_id and session_id , it requires an already created transaction (e.g. by using the methods create_vtt ) or create_data_request ). The request requires the following parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . transaction : Transaction , serialized transaction object. It can be created by using the methods create_vtt ) or create_data_request . Example of a send_transaction for sending 500 nanoWits to an address. { \"jsonrpc\" : \"2.0\" , \"method\" : \"send_transaction\" , \"params\" : { \"wallet_id\" : \"92e724030ed4e0d9c8fafd0ed617e2f7fb08512a36d6e12d30a44a63117aad0d\" , \"session_id\" : \"4e373de7144dc08bc0a2b2efad52c902f4661453328523e42a02201c66716803\" , \"transaction\" : { \"ValueTransfer\" : { \"body\" : { \"inputs\" : [ { \"output_pointer\" : \"5d438cb68c5c24228f6c12d0bb33235159118230948410bfd1e41b7e239d944d:1\" } ], \"outputs\" : [ { \"address\" : \"twit1z8u6ruc4secs48x20qwstl80g8p9nkp3a33ts7\" , \"time_lock\" : 0 , \"value\" : 500 }, { \"address\" : \"twit15aetshda2t435xg965k70w5y5ra8x5kj78m39l\" , \"time_lock\" : 0 , \"value\" : 49470 } ] }, \"signatures\" : [ { \"public_key\" : { \"bytes\" : [ 216 , 133 , 176 , 114 , 224 , 176 , 158 , 76 , 90 , 139 , 124 , 204 , 254 , 172 , 133 , 198 , 205 , 208 , 230 , 93 , 215 , 92 , 47 , 195 , 175 , 136 , 164 , 40 , 81 , 166 , 143 , 83 ], \"compressed\" : 3 }, \"signature\" : { \"Secp256k1\" : { \"der\" : [ 48 , 69 , 2 , 33 , 0 , 238 , 241 , 230 , 193 , 168 , 58 , 205 , 87 , 171 , 157 , 12 , 135 , 233 , 221 , 65 , 131 , 187 , 192 , 197 , 31 , 245 , 202 , 88 , 142 , 137 , 124 , 135 , 28 , 190 , 159 , 190 , 246 , 2 , 32 , 42 , 20 , 65 , 244 , 88 , 251 , 91 , 131 , 13 , 68 , 10 , 82 , 194 , 250 , 36 , 181 , 109 , 200 , 113 , 112 , 237 , 209 , 43 , 212 , 74 , 247 , 128 , 30 , 80 , 111 , 251 , 192 ] } } } ] } } }, \"id\" : 1 } The response includes the JsonRPC response after sending the transaction to the node API and the balance movement that affects the wallet: balance_movement : BalanceMovement , the wallet balance movement, which is pending and has not yet been indexed into a block. jsonrpc_result : Bool , the result of sending the transaction to the node using the intentory JsonRPC API method. { \"jsonrpc\": \"2.0\", \"result\": { \"balance_movement\": { \"amount\": 1, \"transaction\": { \"block\": { \"block_hash\": \"0000000000000000000000000000000000000000000000000000000000000000\", \"epoch\": 0 }, \"confirmed\": false, \"data\": { \"value_transfer\": { \"inputs\": [], \"outputs\": [ { \"address\": \"twit1eghyyar76nuvdfu0h70f4gmxruj2rw4gfnrhnk\", \"time_lock\": 0, \"value\": 1 }, { \"address\": \"twit1ue34u54zr2ezate8hhgrdhgsfvjawykr9kxtqq\", \"time_lock\": 0, \"value\": 998 } ] } }, \"hash\": \"ddab6bee4c95800cca06b3d1e2fafd5f47b97e73f8b6725916ccac6be6537041\", \"miner_fee\": 0, \"timestamp\": 1601544326 }, \"type\": \"NEGATIVE\" }, \"jsonrpc_result\": true }, \"id\": 1 }","title":"send_transaction"},{"location":"developer/wallet-api/#set","text":"The method set allows to store key-value data in the wallet database. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : String , session ID assigned when unlocking the wallet. See unlock_wallet . key : String , key under which the value will be stored. value : Object , JSON object to be stored. { \"jsonrpc\" : \"2.0\" , \"method\" : \"set\" , \"params\" : { \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"session_id\" : \"3cf194594d69c3b2b80a11f30953da96599dd2dd56cf72db838abba092cea3df\" , \"key\" : \"templates\" , \"value\" : { \"name\" : \"object\" } }, \"id\" : 1 } Response: { \"jsonrpc\" : \"2.0\" , \"result\" : null , \"id\" : 1 }","title":"set"},{"location":"developer/wallet-api/#shutdown","text":"To shutdown the wallet. It has no response, directly stops the wallet specified in the parameters. If no session_id is provided, wallet will be shutdown only if there are no open sessions. Request with parameters: session_id (optional): String , session ID assigned when unlocking the wallet. See unlock_wallet . { \"jsonrpc\" : \"2.0\" , \"method\" : \"shutdown\" , \"params\" : { \"session_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" }, \"id\" : \"1\" }","title":"shutdown"},{"location":"developer/wallet-api/#sign_data","text":"This method uses the wallet's master key to sign message data. The parameters are: session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . wallet_id : String , the ID associated to the wallet. See get_wallet_infos . data : String , the data to be signed. extended_pk : Bool , if this flag is set to true, extended public key will be include ( chaincode ). If leaked, wallet public addresses might be derived. Example: { \"jsonrpc\" : \"2.0\" , \"method\" : \"sign_data\" , \"params\" : { \"session_id\" : \"61078ed2685b82854b1d40b23e200994e80a04c2e2ba82e0e92c7adb9e348cad\" , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , \"data\" : \"data\" , \"extended_pk\" : true }, \"id\" : 1 } The response includes the parameters: chaincode : String , cryptographic material used to derive keys. public_key : String , the wallet's public key. signture : String , the signature. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"chaincode\" : \"c42185b347af99f7fbb4bf41f8ea1e9b1be70f1a4507f7cbe62e99f487af4af4\" , \"public_key\" : \"025aaf8c0fd8598a5486085900e1ffe464ef4241281a5fff80389235740d3f19d2\" , \"signature\" : \"30450221008fb3756fb3056df78cd43d0f2abe97a60c203eeb6d5e2180b9f7abad7ade375102207a488ae575abb88f1eaddfdbe72ad1c4738c62f8e96c448c5f7b1ad478199e5d\" }, \"id\" : 1 }","title":"sign_data"},{"location":"developer/wallet-api/#unlock_wallet","text":"The JsonRPC method unlock_wallet is used to unlock the wallet with the specified identifier by providing a decryption key. This key will be hold in memory until the wallet is locked again. By default, sessions will expired after 1 hour. As long as a wallet is unlocked, you can operate it without having to supply the password again by just using the session ID, until it expires. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . password : String , the password that unlocks the wallet. { \"jsonrpc\" : \"2.0\" , \"method\" : \"unlock_wallet\" , \"params\" : { \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"password\" : \"12345678\" }, \"id\" : 1 } Response: session_id : number , generated identifier for the current wallet session. session_expiration_secs : number , amount of seconds after which the session will expire. account_balance : number , wallet's account balance in nano Wits. name : String , human-friendly name for the wallet. caption : String , human-friendly caption for the wallet. current_account : number , identifies the current active account in the session (the current version only supports the default account 0 ). available_accounts : Array , list of available accounts in the wallet. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"account_balance\" : 0 , \"available_accounts\" : [ 0 ], \"caption\" : null , \"current_account\" : 0 , \"name\" : null , \"session_expiration_secs\" : 3200 , \"session_id\" : \"9c4f690a50de45b91bb4a5d7fc964c6853ca4eb29fa4ed3e2c9ddfd3e2da45e7\" }, \"id\" : 1 }","title":"unlock_wallet"},{"location":"developer/wallet-api/#update_wallet","text":"The JsonRPC method update_wallet is used to update the name and/or caption of an existing wallet. Request with parameters: wallet_id : String , the ID associated to the wallet. See get_wallet_infos . session_id : number , generated identifier obtained from unlocking the wallet. See Unlock Wallet . name : String , wallet name shown in get_wallet_infos . description : String , wallet private description (only available for authenticated clients after unlock_wallet ). { \"jsonrpc\" : \"2.0\" , \"method\" : \"update_wallet\" , \"params\" : { \"session_id\" : \"f1188c907e581f067ac589cf962c7f4fea9443e93d8df10a945e7d17fae49870\" , \"wallet_id\" : \"6c344625884c2f910065ab170dc18ad3cbbc03c7234507c7c22dbd78e3b26667\" , \"name\" : \"New Name\" , \"description\" : \"New Description\" }, \"id\" : 1 } Response: success : Boolean , reporting if the wallet's update was successfull. { \"jsonrpc\" : \"2.0\" , \"result\" : { \"success\" : true }, \"id\" : 1 }","title":"update_wallet"},{"location":"developer/wallet-api/#validate_mnemonics","text":"The JsonRPC method validate_mnemonics is used to verify that validity of the seed source that might be used to generate a new wallet. Request with parameters: seed_source : \"mnemonics\"|\"xprv\" , literal to identify if the seed source is of the type mnemonics or xprv . seed_data : String , containing the used seed data, either a list of mnemonic words or a xprv . backup_password (optional): String , in case that seed source is \"xprv\" , seed_data must be decrypted with this parameter. { \"jsonrpc\" : \"2.0\" , \"method\" : \"validate_mnemonics\" , \"params\" : { \"seed_source\" : \"mnemonics\" , \"seed_data\" : \"day voice lake monkey suit bread occur own cattle visit object ordinary\" }, \"id\" : 1 } Response: valid : Boolean , true if valid seed in form of mnemonics or xprv . { \"jsonrpc\" : \"2.0\" , \"result\" : { \"exist\" : false , \"wallet_id\" : \"8f5b85981addad621a86f01a1ddb646ccd90620c95247948ce8d99feefd0496c\" , }, \"id\" : 1 }","title":"validate_mnemonics"},{"location":"ethereum/addresses/","text":"Witnet Addresses on Ethereum \u00b6 Ethereum smart contracts can send oracle queries (aka data requests ) to the Witnet decentralized oracle using the witnet-ethereum-bridge Solidity library. The most convenient way to use the witnet-ethereum-bridge library is through the Witnet Truffle Box , because it allows writing Witnet data requests using Javascript, which is automatically compiled to Witnet byte code and then wrapped in a Solidity contract that you can easily import from your own contracts. The Witnet Truffle Box also abstracts away the complexity of having to instantiate or link the Witnet contracts listed here. These addresses are provided for reference, just in case someone prefers not to use the Witnet Truffle Box and rather talk to the Witnet Request Board and other contracts directly using the interfaces in witnet-ethereum-bridge . Mainnet \u00b6 Main contracts \u00b6 CBOR: 0x1D9c4a8f8B7b5F9B8e2641D81927f8F8Cc7fF079 Witnet: 0x916aC9636F4Ea9f54f07c9De8fDCd828e1b32c9B WitnetRequestBoard: 0xd653fbd7c736838289262F0F41A458f35393C88a WitnetRequestBoardProxy: 0x400DbF3645b345823124aaB22D04013A46D9ceD5 Public price feeds \u00b6 BtcUsdPriceFeed: 0xF2712e7114A237625EFC8bBA6a6ed1Bb8b6029c9 EthUsdPriceFeed: 0x1ebD93231a7fE551E1d6405404Df34909eff4c2C Rinkeby \u00b6 Main contracts \u00b6 CBOR: 0xa3AFD68122a21c7D21Ddd95E5c077f958dA46662 Witnet: 0x5259aCEfF613b37aF35999798A6da60bEF326038 WitnetRequestBoard: 0xb55Ab5eDeb7256242Ae4C632e75bcbd4E6cc1fbB WitnetRequestBoardProxy: 0x9b42b0D80C428B17A5828dF5C2c96454ca54bD04 Public price feeds \u00b6 BtcUsdPriceFeed: 0x58995FaD03158fB9cd64397347bA97714EF8fC12 EthUsdPriceFeed: 0xAe9821fbA4Bd76fd6D39859bd7c3d4A90b2ceE40 Goerli \u00b6 Main contracts \u00b6 CBOR: 0x9905821089928e5A26841225510cea8B2984F6D8 Witnet: 0x9b42b0D80C428B17A5828dF5C2c96454ca54bD04 WitnetRequestBoard: 0xAf89a59876145202a027E73340592F05B28A6D99 WitnetRequestBoardProxy: 0x0C4be6AA667df48de54BA174bE7948875fdf152B Public price feeds \u00b6 BtcUsdPriceFeed: 0x4958806608D2E3Aa22BD8818B555A0a24fe6c38E EthUsdPriceFeed: 0xAa0AA725aEb1d382F909a8dE3041e9eaD6507501 Kovan \u00b6 Main contracts \u00b6 CBOR: 0xB4B2E2e00e9d6E5490d55623E4F403EC84c6D33f Witnet: 0xD9465D38f50f364b3263Cb219e58d4dB2D584530 WitnetRequestBoard: 0x7D8A488BACB56dA2De17628e26a21fFd97792b81 WitnetRequestBoardProxy: 0xD9a6d1Ea0d0f4795985725C7Bd40C31a667c033d Public price feeds \u00b6 BtcUsdPriceFeed: 0x9b3C5A6cB55E027d9ae6f265f6FB6fFA86e7b35E EthUsdPriceFeed: 0xA996939e6a07a0D1D6376c59BE515d8441f5E9b8","title":"Addresses"},{"location":"ethereum/addresses/#witnet-addresses-on-ethereum","text":"Ethereum smart contracts can send oracle queries (aka data requests ) to the Witnet decentralized oracle using the witnet-ethereum-bridge Solidity library. The most convenient way to use the witnet-ethereum-bridge library is through the Witnet Truffle Box , because it allows writing Witnet data requests using Javascript, which is automatically compiled to Witnet byte code and then wrapped in a Solidity contract that you can easily import from your own contracts. The Witnet Truffle Box also abstracts away the complexity of having to instantiate or link the Witnet contracts listed here. These addresses are provided for reference, just in case someone prefers not to use the Witnet Truffle Box and rather talk to the Witnet Request Board and other contracts directly using the interfaces in witnet-ethereum-bridge .","title":"Witnet Addresses on Ethereum"},{"location":"ethereum/addresses/#mainnet","text":"","title":"Mainnet"},{"location":"ethereum/addresses/#main-contracts","text":"CBOR: 0x1D9c4a8f8B7b5F9B8e2641D81927f8F8Cc7fF079 Witnet: 0x916aC9636F4Ea9f54f07c9De8fDCd828e1b32c9B WitnetRequestBoard: 0xd653fbd7c736838289262F0F41A458f35393C88a WitnetRequestBoardProxy: 0x400DbF3645b345823124aaB22D04013A46D9ceD5","title":"Main contracts"},{"location":"ethereum/addresses/#public-price-feeds","text":"BtcUsdPriceFeed: 0xF2712e7114A237625EFC8bBA6a6ed1Bb8b6029c9 EthUsdPriceFeed: 0x1ebD93231a7fE551E1d6405404Df34909eff4c2C","title":"Public price feeds"},{"location":"ethereum/addresses/#rinkeby","text":"","title":"Rinkeby"},{"location":"ethereum/addresses/#main-contracts_1","text":"CBOR: 0xa3AFD68122a21c7D21Ddd95E5c077f958dA46662 Witnet: 0x5259aCEfF613b37aF35999798A6da60bEF326038 WitnetRequestBoard: 0xb55Ab5eDeb7256242Ae4C632e75bcbd4E6cc1fbB WitnetRequestBoardProxy: 0x9b42b0D80C428B17A5828dF5C2c96454ca54bD04","title":"Main contracts"},{"location":"ethereum/addresses/#public-price-feeds_1","text":"BtcUsdPriceFeed: 0x58995FaD03158fB9cd64397347bA97714EF8fC12 EthUsdPriceFeed: 0xAe9821fbA4Bd76fd6D39859bd7c3d4A90b2ceE40","title":"Public price feeds"},{"location":"ethereum/addresses/#goerli","text":"","title":"Goerli"},{"location":"ethereum/addresses/#main-contracts_2","text":"CBOR: 0x9905821089928e5A26841225510cea8B2984F6D8 Witnet: 0x9b42b0D80C428B17A5828dF5C2c96454ca54bD04 WitnetRequestBoard: 0xAf89a59876145202a027E73340592F05B28A6D99 WitnetRequestBoardProxy: 0x0C4be6AA667df48de54BA174bE7948875fdf152B","title":"Main contracts"},{"location":"ethereum/addresses/#public-price-feeds_2","text":"BtcUsdPriceFeed: 0x4958806608D2E3Aa22BD8818B555A0a24fe6c38E EthUsdPriceFeed: 0xAa0AA725aEb1d382F909a8dE3041e9eaD6507501","title":"Public price feeds"},{"location":"ethereum/addresses/#kovan","text":"","title":"Kovan"},{"location":"ethereum/addresses/#main-contracts_3","text":"CBOR: 0xB4B2E2e00e9d6E5490d55623E4F403EC84c6D33f Witnet: 0xD9465D38f50f364b3263Cb219e58d4dB2D584530 WitnetRequestBoard: 0x7D8A488BACB56dA2De17628e26a21fFd97792b81 WitnetRequestBoardProxy: 0xD9a6d1Ea0d0f4795985725C7Bd40C31a667c033d","title":"Main contracts"},{"location":"ethereum/addresses/#public-price-feeds_3","text":"BtcUsdPriceFeed: 0x9b3C5A6cB55E027d9ae6f265f6FB6fFA86e7b35E EthUsdPriceFeed: 0xA996939e6a07a0D1D6376c59BE515d8441f5E9b8","title":"Public price feeds"},{"location":"ethereum/price-feeds/","text":"Witnet Public Price Feeds \u00b6 Witnet Foundation operates a series of public price feeds both for showcasing the capabilities of the Witnet oracle, and as a public service for the broader Ethereum community. All Witnet price feeds comply with the ERC-2362 interface: a standard interface for price feeds, cooperatively envisioned by Witnet, Tellor, Band, Razor and other oracles. Therefore, using any of these price feeds is as simple as: pragma solidity >= 0.5.0 < 0.9.0 ; import \"ado-contracts/contracts/interfaces/IERC2362.sol\" ; contract MyContract { function readFromPriceFeed () external view returns ( int256 ) { IERC2362 priceFeed = IERC2362 ( \"<address of the price feed>\" ); bytes32 assetID = bytes32 ( hex ( \"<asset ID>\" )); int256 value = priceFeed . valueFor ( assetID ); return value ; } } The available asset IDs for each of the public price feeds are also listed down below. A full list of asset IDs can be found in ADOIP-0010 . Floats and decimal digits As Solidity does not currently support float types, all prices are provided as int256 , with a specific number of decimal digits. For example, if the BTC/USD price is 31371.21 , the BTC/USD contract below will give 31371210 because it is using 3 decimal digits. BTC/USD \u00b6 Source code: Solidity contract Witnet data request Asset ID: 637b7efb6b620736c247aaa282f3898914c0bef6c12faff0d3fe9d4bea783020 Decimal digits: 3 Mainnet \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee12557eb70e Contract address: 0xF2712e7114A237625EFC8bBA6a6ed1Bb8b6029c9 Rinkeby \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592eeca197eb710 Contract address: 0x58995FaD03158fB9cd64397347bA97714EF8fC12 Goerli \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592eea6487eb712 Contract address: 0x4958806608D2E3Aa22BD8818B555A0a24fe6c38E Kovan \u00b6 Contract address: 0x9b3C5A6cB55E027d9ae6f265f6FB6fFA86e7b35E ETH/USD \u00b6 Source code: Solidity contract Witnet data request Asset ID: dfaa6f747f0f012e8f2069d6ecacff25f5cdf0258702051747439949737fc0b5 Decimal digits: 3 Mainnet \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee6a487eb70f Contract address: 0x1ebD93231a7fE551E1d6405404Df34909eff4c2C Rinkeby \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee49817eb711 Contract address: 0xAe9821fbA4Bd76fd6D39859bd7c3d4A90b2ceE40 Goerli \u00b6 Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee573a7eb713 Contract address: 0xAa0AA725aEb1d382F909a8dE3041e9eaD6507501 Kovan \u00b6 Contract address: 0xA996939e6a07a0D1D6376c59BE515d8441f5E9b8","title":"Price Feeds"},{"location":"ethereum/price-feeds/#witnet-public-price-feeds","text":"Witnet Foundation operates a series of public price feeds both for showcasing the capabilities of the Witnet oracle, and as a public service for the broader Ethereum community. All Witnet price feeds comply with the ERC-2362 interface: a standard interface for price feeds, cooperatively envisioned by Witnet, Tellor, Band, Razor and other oracles. Therefore, using any of these price feeds is as simple as: pragma solidity >= 0.5.0 < 0.9.0 ; import \"ado-contracts/contracts/interfaces/IERC2362.sol\" ; contract MyContract { function readFromPriceFeed () external view returns ( int256 ) { IERC2362 priceFeed = IERC2362 ( \"<address of the price feed>\" ); bytes32 assetID = bytes32 ( hex ( \"<asset ID>\" )); int256 value = priceFeed . valueFor ( assetID ); return value ; } } The available asset IDs for each of the public price feeds are also listed down below. A full list of asset IDs can be found in ADOIP-0010 . Floats and decimal digits As Solidity does not currently support float types, all prices are provided as int256 , with a specific number of decimal digits. For example, if the BTC/USD price is 31371.21 , the BTC/USD contract below will give 31371210 because it is using 3 decimal digits.","title":"Witnet Public Price Feeds"},{"location":"ethereum/price-feeds/#btcusd","text":"Source code: Solidity contract Witnet data request Asset ID: 637b7efb6b620736c247aaa282f3898914c0bef6c12faff0d3fe9d4bea783020 Decimal digits: 3","title":"BTC/USD"},{"location":"ethereum/price-feeds/#mainnet","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee12557eb70e Contract address: 0xF2712e7114A237625EFC8bBA6a6ed1Bb8b6029c9","title":"Mainnet"},{"location":"ethereum/price-feeds/#rinkeby","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592eeca197eb710 Contract address: 0x58995FaD03158fB9cd64397347bA97714EF8fC12","title":"Rinkeby"},{"location":"ethereum/price-feeds/#goerli","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592eea6487eb712 Contract address: 0x4958806608D2E3Aa22BD8818B555A0a24fe6c38E","title":"Goerli"},{"location":"ethereum/price-feeds/#kovan","text":"Contract address: 0x9b3C5A6cB55E027d9ae6f265f6FB6fFA86e7b35E","title":"Kovan"},{"location":"ethereum/price-feeds/#ethusd","text":"Source code: Solidity contract Witnet data request Asset ID: dfaa6f747f0f012e8f2069d6ecacff25f5cdf0258702051747439949737fc0b5 Decimal digits: 3","title":"ETH/USD"},{"location":"ethereum/price-feeds/#mainnet_1","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee6a487eb70f Contract address: 0x1ebD93231a7fE551E1d6405404Df34909eff4c2C","title":"Mainnet"},{"location":"ethereum/price-feeds/#rinkeby_1","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee49817eb711 Contract address: 0xAe9821fbA4Bd76fd6D39859bd7c3d4A90b2ceE40","title":"Rinkeby"},{"location":"ethereum/price-feeds/#goerli_1","text":"Data explorer: feeds.witnet.io/feeds/60f2ad37f592ee573a7eb713 Contract address: 0xAa0AA725aEb1d382F909a8dE3041e9eaD6507501","title":"Goerli"},{"location":"ethereum/price-feeds/#kovan_1","text":"Contract address: 0xA996939e6a07a0D1D6376c59BE515d8441f5E9b8","title":"Kovan"},{"location":"node-operators/cli/","text":"Command Line Interface (CLI) \u00b6 The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API . Usage \u00b6 See all the available options by running the help command using docker, binary or cargo. Docker docker exec witnet_node witnet node --help Binary witnet node --help Cargo cargo run -- node --help To get more information about any specific command, simply add --help at the end. For instance, this will show the available options for the blockchain command: Docker docker exec witnet_node witnet node blockchain --help Binary witnet node blockchain --help Cargo cargo run -- node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . Docker docker exec witnet_node witnet node -c witnet.toml node blockchain Binary witnet -c witnet.toml node blockchain Cargo cargo run -- -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. Docker docker exec witnet_node witnet node -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Binary witnet -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Cargo cargo run -- -c witnet.toml node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. Docker docker exec witnet_node witnet node node blockchain Error: Connection refused (os error 111) Binary witnet node blockchain Error: Connection refused (os error 111) Cargo cargo run -- node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : Docker $ docker exec witnet_node witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Binary $ RUST_LOG=witnet=debug witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Cargo $ RUST_LOG=witnet=debug cargo run -- node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Commands \u00b6 addPeers \u00b6 Add addresses to the node's peers and try to connect to them. The IP addresses are expected in format: list of \"address:port\" separated by spaces. Docker docker exec witnet_node witnet node addPeers 52.166.178.145:21337 52.166.178.145:22337 Binary witnet node addPeers 52.166.178.145:12337 52.166.178.145:22337 Cargo cargo run -- node addPeers 52.166.178.145:12337 52.166.178.145:22337 Example output: Successfully added peer addresses: [\"52.166.178.145:12337\", \"52.166.178.145:22337\"] address \u00b6 Get the identifier of the node that acts as its address when interacting with the protocol through transactions. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. Docker docker exec witnet_node witnet node address Binary witnet node address Cargo cargo run -- node address Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr balance \u00b6 Get total balance of a given Witnet address. Balances are shown in wits. --address=address : address for which to get balance. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node balance docker exec witnet_node witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node balance witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node balance cargo run -- node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099.999950005 wits block \u00b6 Print out detailed information about a block being queried by its hash. Docker docker exec witnet_node witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Binary witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Cargo cargo run -- node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" } blockchain \u00b6 List block hashes in the local block chain, matched with their epochs. Docker docker exec witnet_node witnet node blockchain Binary witnet node blockchain Cargo cargo --run node blockchain This method accepts two optional arguments: --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. Docker # Get all the block hashes from the genesis block docker exec witnet_node witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] docker exec witnet_node witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs docker exec witnet_node witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago docker exec witnet_node witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block docker exec witnet_node witnet node blockchain --epoch=-1 --limit=1 Binary # Get all the block hashes from the genesis block witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block witnet node blockchain --epoch=-1 --limit=1 Cargo # Get all the block hashes from the genesis block cargo run -- node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] cargo run -- node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs cargo run -- node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago cargo run -- node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block cargo run -- node blockchain --epoch=-1 --limit=1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4 dataRequestReport \u00b6 Show information about a data request. Docker docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Example output: Report for data request 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d: Deployed in block 159045c67d97e284588be4da89a43319735919144b2aaf1468e7eae6682f42b6 by twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl FINISHED with 2 commits and 2 reveals Commit rounds: 1/2 Reveal rounds: 1/2 Reveals: [Rewarded ] twit1xpc5d7dz6rsnnjrlp98vtn496qzrawu7y5cyx4: RadonTypes::RadonFloat(10172.642950000001) [Rewarded ] twit1xcnfm3q57h7uh7y2m23y6hd7jsqufyrlmxgfnq: RadonTypes::RadonFloat(10172.642950000001) Tally: RadonTypes::RadonFloat(10172.642950000001) If you want to see the request move forwards through its different stages in real time you can use the watch command while it is being resolved: Docker watch --color docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary watch --color witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo watch --color cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d joinTransaction \u00b6 Create a value transfer transaction that joins UTXOs. The following arguments must be provided. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --fee=1 Binary witnet node joinTransaction --value=100 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --fee=1 knownPeers \u00b6 Get the list of peer addresses known to the node. These addresses are tagged as: Docker docker exec witnet_node witnet node knownPeers Binary witnet node knownPeers Cargo cargo run -- node knownPeers masterKeyExport \u00b6 Export the node's master private key. Please keep this totally secret. Anyone with knowledge of this key has full access to all your wit tokens. Docker docker exec witnet_node witnet node masterKeyExport Binary witnet node masterkeyExport Cargo cargo run -- node masterkeyExport minerList \u00b6 Display the list of block hashes for each epoch, their miners and the numbers of blocks mined by each address. Docker docker exec witnet_node ./witnet node minerList Binary witnet node minerList Cargo cargo run -- node minerList nodeStats \u00b6 Display local node stats. Docker docker exec witnet_node witnet node nodeStats Cargo cargo run -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"): Block mining stats Proposed blocks Blocks included in the block chain Data Request mining stats: Times with eligibility to mine a data request Proposed commits Accepted commits Slashed commits Example output: Block mining stats: - Proposed blocks: 81 - Blocks included in the block chain: 1 Data Request mining stats: - Times with eligibility to mine a data request: 2 - Proposed commits: 0 - Accepted commits: 0 - Slashed commits: 0 Tip Note that it is perfectly normal for a node to show 0 \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. output \u00b6 Display a transaction output, as referred by it's \"output pointer\", that is, <transaction_id>:<output_index> . Docker docker exec witnet_node witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d:0 Binary witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d peers \u00b6 List inbound and outbound connections currently established by the node. Outbound connections are those initiated on our side, and inbound connections are those that were initiated by peer nodes. A node that does not announce a public address (IP and port) will normally have no inbound connections, as there is no way for other nodes to discover a valid network route to it. Docker docker exec witnet_node witnet node peers Binary witnet node peers Cargo cargo run -- node peers raw \u00b6 The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way (don't forget the -i flag when using Docker): each line of user input will be sent to the JSON-RPC server without any modifications: Docker $ docker exec -i witnet_node witnet node raw Binary $ witnet -c witnet.toml node raw Cargo $ cargo run -- -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"blockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments. For instance, the bitcoin_price.json data request example from the witnet-rust reposity can be easily deployed into the network using the raw command like this: Docker cat examples/bitcoin_price.json | docker exec -i witnet_node witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Binary cat examples/bitcoin_price.json | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Cargo cat examples/bitcoin_price.json | cargo run -- node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} reputation \u00b6 Displays the reputation score associated with a given Witnet address and its elegibility to mine a block. --address=address : address for which to get reputation score. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node reputation docker exec witnet_node witnet node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Binary witnet node reputation witnet node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Cargo cargo run -- node reputation cargo run -- node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Example output: [A] twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 -> Reputation: 1, Eligibility: 28.571429% The parameter [A] notifies that the node is active. Adding the flag --all lists all the nodes active and their elegibility. It also lists the nodes with reputation grater than 0 but not active, if any. Tip Note that it is perfectly normal for a node to show 0 reputation for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Docker docker exec witnet_node witnet node reputation --all Binary witnet node reputation --all Cargo cargo run -- node reputation --all Example output: Total Reputation: { [A] twit1hgert0dwtfmfcnv34epvjyhwamny20vkx09zjc -> Reputation: 2, Eligibility: 42.857143% [A] twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 -> Reputation: 1, Eligibility: 28.571429% [A] twit18gqex3jg4pazz5am2588fc89qyvg350gs603j2 -> Reputation: 1, Eligibility: 28.571429% } send \u00b6 Create and broadcast a value transfer transaction. That is, send some amount of wit tokens from the node's own balance into a different Witnet address. --address=address : recipient address. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Example with time lock set to 2019-10-01 Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} sendRequest \u00b6 Send a serialized data request. An example of how to create such a request can be found in the tutorial . Docker docker exec witnet_node witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" Cargo cargo run -- node sendRequest --hex \"data request output serialized in hexadecimal format\" Binary witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" server \u00b6 Run a Witnet node server. Docker docker exec witnet_node witnet node server Binary witnet node server Cargo cargo run -- node server splitTransaction \u00b6 Create a value transfer transaction that splits UTXOs. The following arguments must be provided: --value=amount : amount in nanoWits. --size=size : amount in nanoWits of each UTXO. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --size=3 --fee=1 Binary witnet node joinTransaction --value=100 --size=3 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --size=3 --fee=1 transaction \u00b6 Print out detailed information about a transaction being queried by its hash. Docker docker exec witnet_node witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Binary witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Cargo cargo run -- node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 The hash of the transaction should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"blockHash\" : \"0c29023ec3c8c9e1a51871a67e235168315160d9f757737c2c390f0a35ad1b24\" , \"transaction\" :{ \"ValueTransfer\" :{ \"body\" :{ \"inputs\" :[{ \"output_pointer\" : \"126549b3ea96f40bb211660d7991109d72b43e68e846ea76d4d2f6cd5a3cc7ff:1\" }], \"outputs\" :[{ \"pkh\" : \"twit12nqlkyp0zfhthfz898tplh3ns7nedcvlezx4r4\" , \"time_lock\" : 0 , \"value\" : 100 },{ \"pkh\" : \"twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl\" , \"time_lock\" : 0 , \"value\" : 499999999987 }]}, \"signatures\" :[{ \"public_key\" :{ \"bytes\" :[ 109 , 158 , 138 , 247 , 58 , 8 , 183 , 138 , 57 , 113 , 147 , 147 , 136 , 177 , 252 , 244 , 33 , 147 , 143 , 200 , 255 , 89 , 208 , 192 , 214 , 81 , 128 , 224 , 219 , 180 , 136 , 155 ], \"compressed\" : 3 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 25 , 163 , 14 , 139 , 5 , 92 , 35 , 157 , 90 , 73 , 162 , 93 , 88 , 67 , 117 , 152 , 104 , 178 , 208 , 225 , 123 , 131 , 236 , 59 , 240 , 136 , 18 , 55 , 79 , 168 , 12 , 218 , 2 , 32 , 76 , 68 , 59 , 125 , 99 , 133 , 74 , 11 , 232 , 70 , 157 , 116 , 68 , 151 , 70 , 39 , 187 , 132 , 190 , 110 , 245 , 214 , 29 , 179 , 198 , 182 , 24 , 133 , 137 , 177 , 187 , 142 ]}}}]}}}, \"id\" : \"1\" } utxos \u00b6 Get the unspent transaction outputs of the node. This shows how many UTXOs are available for your node to spend or collateralize. Docker docker exec witnet_node witnet node utxos Binary witnet node utxos Cargo cargo run -- node utxos The output includes information about: Total number of utxos Total number of utxos bigger than collateral minimum Total number of utxos older than collateral coinage The flag --long can be added to the command to get a detailed list of the UTXOs and whether each of them is spendable or collateralizable at this time.","title":"Command Line Interface"},{"location":"node-operators/cli/#command-line-interface-cli","text":"The cli subcommand provides a human-friendly command-line interface to the node JSON-RPC API .","title":"Command Line Interface (CLI)"},{"location":"node-operators/cli/#usage","text":"See all the available options by running the help command using docker, binary or cargo. Docker docker exec witnet_node witnet node --help Binary witnet node --help Cargo cargo run -- node --help To get more information about any specific command, simply add --help at the end. For instance, this will show the available options for the blockchain command: Docker docker exec witnet_node witnet node blockchain --help Binary witnet node blockchain --help Cargo cargo run -- node blockchain --help The JSON-RPC server address is obtained from the configuration file . The path of this file can be set using the -c or --config flag. This flag must appear before node . Docker docker exec witnet_node witnet node -c witnet.toml node blockchain Binary witnet -c witnet.toml node blockchain Cargo cargo run -- -c witnet.toml node blockchain You can use the -n flag to easily overwrite the node address. This flag must appear after the command name. Docker docker exec witnet_node witnet node -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Binary witnet -c witnet.toml node blockchain -n \"127.0.0.1:1234\" Cargo cargo run -- -c witnet.toml node blockchain -n \"127.0.0.1:1234\" If there is any error, the process will return a non-zero exit code. Docker docker exec witnet_node witnet node node blockchain Error: Connection refused (os error 111) Binary witnet node blockchain Error: Connection refused (os error 111) Cargo cargo run -- node blockchain Error: Connection refused (os error 111) The executable implements the usual logging API, which can be enabled using RUST_LOG=witnet=debug : Docker $ docker exec witnet_node witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Binary $ RUST_LOG=witnet=debug witnet node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111) Cargo $ RUST_LOG=witnet=debug cargo run -- node blockchain INFO 2019-01-03T12:04:43Z: witnet::json_rpc_client: Connecting to JSON-RPC server at 127.0.0.1:21338 ERROR 2019-01-03T12:04:43Z: witnet: Error: Connection refused (os error 111)","title":"Usage"},{"location":"node-operators/cli/#commands","text":"","title":"Commands"},{"location":"node-operators/cli/#addpeers","text":"Add addresses to the node's peers and try to connect to them. The IP addresses are expected in format: list of \"address:port\" separated by spaces. Docker docker exec witnet_node witnet node addPeers 52.166.178.145:21337 52.166.178.145:22337 Binary witnet node addPeers 52.166.178.145:12337 52.166.178.145:22337 Cargo cargo run -- node addPeers 52.166.178.145:12337 52.166.178.145:22337 Example output: Successfully added peer addresses: [\"52.166.178.145:12337\", \"52.166.178.145:22337\"]","title":"addPeers"},{"location":"node-operators/cli/#address","text":"Get the identifier of the node that acts as its address when interacting with the protocol through transactions. This is the address used for mining blocks, resolving data requests, and receiving value transfer transactions. Docker docker exec witnet_node witnet node address Binary witnet node address Cargo cargo run -- node address Example output: twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr","title":"address"},{"location":"node-operators/cli/#balance","text":"Get total balance of a given Witnet address. Balances are shown in wits. --address=address : address for which to get balance. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node balance docker exec witnet_node witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Binary witnet node balance witnet node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Cargo cargo run -- node balance cargo run -- node balance --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr Example output: 34099.999950005 wits","title":"balance"},{"location":"node-operators/cli/#block","text":"Print out detailed information about a block being queried by its hash. Docker docker exec witnet_node witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Binary witnet node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 Cargo cargo run -- node block 9372e2ed0c637a9733e92d7e0d4f1aa1f297c43a80bc3be57fc7d7738efb0ef4 The hash of the block should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"block_header\" :{ \"beacon\" :{ \"checkpoint\" : 74005 , \"hashPrevBlock\" : \"ac6ec0020e726577fa3df3fd04de2a30b020c4a864602375a129e090707a90dc\" }, \"merkle_roots\" :{ \"commit_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"dr_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"mint_hash\" : \"a02e6038ec2a472d6daa8f374bdeca84a62cd5731d33dd865f497f34360874ef\" , \"reveal_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"tally_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" , \"vt_hash_merkle_root\" : \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\" }, \"proof\" :{ \"proof\" :{ \"proof\" :[ 2 , 76 , 213 , 68 , 242 , 86 , 29 , 133 , 44 , 102 , 231 , 220 , 74 , 198 , 196 , 117 , 106 , 87 , 200 , 168 , 77 , 176 , 129 , 130 , 10 , 164 , 24 , 13 , 131 , 141 , 240 , 28 , 46 , 72 , 247 , 80 , 196 , 178 , 67 , 144 , 46 , 246 , 44 , 191 , 20 , 119 , 187 , 160 , 110 , 73 , 60 , 243 , 160 , 231 , 188 , 124 , 69 , 238 , 130 , 148 , 69 , 137 , 102 , 60 , 56 , 33 , 62 , 127 , 90 , 62 , 47 , 62 , 77 , 79 , 163 , 151 , 49 , 233 , 127 , 65 , 103 ], \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }}}, \"version\" : 0 }, \"block_sig\" :{ \"public_key\" :{ \"bytes\" :[ 163 , 236 , 130 , 238 , 47 , 169 , 114 , 32 , 51 , 173 , 139 , 216 , 109 , 148 , 153 , 253 , 189 , 195 , 194 , 125 , 3 , 156 , 222 , 125 , 123 , 96 , 212 , 247 , 24 , 171 , 132 , 136 ], \"compressed\" : 2 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 13 , 144 , 153 , 43 , 104 , 8 , 14 , 205 , 157 , 88 , 181 , 226 , 110 , 189 , 101 , 148 , 248 , 193 , 170 , 99 , 177 , 219 , 228 , 149 , 239 , 34 , 1 , 245 , 13 , 207 , 123 , 220 , 2 , 32 , 108 , 71 , 130 , 109 , 147 , 73 , 92 , 96 , 149 , 102 , 125 , 144 , 146 , 252 , 143 , 66 , 74 , 105 , 52 , 185 , 196 , 217 , 95 , 249 , 157 , 11 , 108 , 254 , 35 , 187 , 67 , 12 ]}}}, \"txns\" :{ \"commit_txns\" :[], \"data_request_txns\" :[], \"mint\" :{ \"epoch\" : 74005 , \"output\" :{ \"pkh\" : \"twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr\" , \"time_lock\" : 0 , \"value\" : 50000000000 }}, \"reveal_txns\" :[], \"tally_txns\" :[], \"value_transfer_txns\" :[]}}, \"id\" : \"1\" }","title":"block"},{"location":"node-operators/cli/#blockchain","text":"List block hashes in the local block chain, matched with their epochs. Docker docker exec witnet_node witnet node blockchain Binary witnet node blockchain Cargo cargo --run node blockchain This method accepts two optional arguments: --epoch=n : the first epoch for which to show block hashes. A negative epoch means \"n epochs ago\". --limit=n : the number of epochs. If zero, unlimited. Docker # Get all the block hashes from the genesis block docker exec witnet_node witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] docker exec witnet_node witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs docker exec witnet_node witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago docker exec witnet_node witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block docker exec witnet_node witnet node blockchain --epoch=-1 --limit=1 Binary # Get all the block hashes from the genesis block witnet node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] witnet node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs witnet node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago witnet node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block witnet node blockchain --epoch=-1 --limit=1 Cargo # Get all the block hashes from the genesis block cargo run -- node blockchain --epoch=0 --limit=0 # Get the block hashes from epochs [ 0 , 19 ] cargo run -- node blockchain --epoch=0 --limit=20 # Get the block hashes from the last 10 epochs cargo run -- node blockchain --epoch=-10 --limit=0 # Get the block hash from 10 epochs ago cargo run -- node blockchain --epoch=-10 --limit=1 # Get the block hash from the last block cargo run -- node blockchain --epoch=-1 --limit=1 Example output: block for epoch #76229 had digest 8dd75bb0d5475a93c27c4166677fbb3bc154e6731c7e07ecad549a58851c84a4","title":"blockchain"},{"location":"node-operators/cli/#datarequestreport","text":"Show information about a data request. Docker docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Example output: Report for data request 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d: Deployed in block 159045c67d97e284588be4da89a43319735919144b2aaf1468e7eae6682f42b6 by twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl FINISHED with 2 commits and 2 reveals Commit rounds: 1/2 Reveal rounds: 1/2 Reveals: [Rewarded ] twit1xpc5d7dz6rsnnjrlp98vtn496qzrawu7y5cyx4: RadonTypes::RadonFloat(10172.642950000001) [Rewarded ] twit1xcnfm3q57h7uh7y2m23y6hd7jsqufyrlmxgfnq: RadonTypes::RadonFloat(10172.642950000001) Tally: RadonTypes::RadonFloat(10172.642950000001) If you want to see the request move forwards through its different stages in real time you can use the watch command while it is being resolved: Docker watch --color docker exec witnet_node witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Binary watch --color witnet node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo watch --color cargo run -- node dataRequestReport 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d","title":"dataRequestReport"},{"location":"node-operators/cli/#jointransaction","text":"Create a value transfer transaction that joins UTXOs. The following arguments must be provided. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --fee=1 Binary witnet node joinTransaction --value=100 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --fee=1","title":"joinTransaction"},{"location":"node-operators/cli/#knownpeers","text":"Get the list of peer addresses known to the node. These addresses are tagged as: Docker docker exec witnet_node witnet node knownPeers Binary witnet node knownPeers Cargo cargo run -- node knownPeers","title":"knownPeers"},{"location":"node-operators/cli/#masterkeyexport","text":"Export the node's master private key. Please keep this totally secret. Anyone with knowledge of this key has full access to all your wit tokens. Docker docker exec witnet_node witnet node masterKeyExport Binary witnet node masterkeyExport Cargo cargo run -- node masterkeyExport","title":"masterKeyExport"},{"location":"node-operators/cli/#minerlist","text":"Display the list of block hashes for each epoch, their miners and the numbers of blocks mined by each address. Docker docker exec witnet_node ./witnet node minerList Binary witnet node minerList Cargo cargo run -- node minerList","title":"minerList"},{"location":"node-operators/cli/#nodestats","text":"Display local node stats. Docker docker exec witnet_node witnet node nodeStats Cargo cargo run -- node nodeStats Binary witnet node nodeStats Among other information, this shows counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"): Block mining stats Proposed blocks Blocks included in the block chain Data Request mining stats: Times with eligibility to mine a data request Proposed commits Accepted commits Slashed commits Example output: Block mining stats: - Proposed blocks: 81 - Blocks included in the block chain: 1 Data Request mining stats: - Times with eligibility to mine a data request: 2 - Proposed commits: 0 - Accepted commits: 0 - Slashed commits: 0 Tip Note that it is perfectly normal for a node to show 0 \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons.","title":"nodeStats"},{"location":"node-operators/cli/#output","text":"Display a transaction output, as referred by it's \"output pointer\", that is, <transaction_id>:<output_index> . Docker docker exec witnet_node witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d:0 Binary witnet node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d Cargo cargo run -- node output 33c656101dd1dfa2258415d6487c648152b95983d1151f46a679b5d1902f6a8d","title":"output"},{"location":"node-operators/cli/#peers","text":"List inbound and outbound connections currently established by the node. Outbound connections are those initiated on our side, and inbound connections are those that were initiated by peer nodes. A node that does not announce a public address (IP and port) will normally have no inbound connections, as there is no way for other nodes to discover a valid network route to it. Docker docker exec witnet_node witnet node peers Binary witnet node peers Cargo cargo run -- node peers","title":"peers"},{"location":"node-operators/cli/#raw","text":"The raw command allows sending raw JSON-RPC requests from the command line. It can be used in an interactive way (don't forget the -i flag when using Docker): each line of user input will be sent to the JSON-RPC server without any modifications: Docker $ docker exec -i witnet_node witnet node raw Binary $ witnet -c witnet.toml node raw Cargo $ cargo run -- -c witnet.toml node raw Each block represents a method call: the first line is a request, the second line is a response. hi { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } { \"jsonrpc\" : \"2.0\" , \"method\" : \"blockChain\" , \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"result\" : [[ 242037 , \"3f8c9ed0fa721e39de9483f61f290f76a541757a828e54a8d951101b1940c59a\" ]], \"id\" : 1 } { \"jsonrpc\" : \"2.0\" , \"method\" : \"someInvalidMethod\" , \"id\" : 2 } { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32601 , \"message\" : \"Method not found\" }, \"id\" : 2 } bye { \"jsonrpc\" : \"2.0\" , \"error\" : { \"code\" :- 32700 , \"message\" : \"Parse error\" }, \"id\" : null } Alternatively, the input can be read from a file using pipes, as is usual in Unix-like environments. For instance, the bitcoin_price.json data request example from the witnet-rust reposity can be easily deployed into the network using the raw command like this: Docker cat examples/bitcoin_price.json | docker exec -i witnet_node witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Binary cat examples/bitcoin_price.json | witnet node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"} Cargo cat examples/bitcoin_price.json | cargo run -- node raw {\"jsonrpc\":\"2.0\",\"result\":\"06e19d996a6776d6cd1ca215f6acd0975d71e64a9dacc06fcfdd7b2538cdbf6d\",\"id\":\"1\"}","title":"raw"},{"location":"node-operators/cli/#reputation","text":"Displays the reputation score associated with a given Witnet address and its elegibility to mine a block. --address=address : address for which to get reputation score. If omitted, defaults to the node's own address. Docker docker exec witnet_node witnet node reputation docker exec witnet_node witnet node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Binary witnet node reputation witnet node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Cargo cargo run -- node reputation cargo run -- node reputation --address=twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 Example output: [A] twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 -> Reputation: 1, Eligibility: 28.571429% The parameter [A] notifies that the node is active. Adding the flag --all lists all the nodes active and their elegibility. It also lists the nodes with reputation grater than 0 but not active, if any. Tip Note that it is perfectly normal for a node to show 0 reputation for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Docker docker exec witnet_node witnet node reputation --all Binary witnet node reputation --all Cargo cargo run -- node reputation --all Example output: Total Reputation: { [A] twit1hgert0dwtfmfcnv34epvjyhwamny20vkx09zjc -> Reputation: 2, Eligibility: 42.857143% [A] twit1p2my760gmg4gwsnhunwnx3epvj9c4whnsnn8j4 -> Reputation: 1, Eligibility: 28.571429% [A] twit18gqex3jg4pazz5am2588fc89qyvg350gs603j2 -> Reputation: 1, Eligibility: 28.571429% }","title":"reputation"},{"location":"node-operators/cli/#send","text":"Create and broadcast a value transfer transaction. That is, send some amount of wit tokens from the node's own balance into a different Witnet address. --address=address : recipient address. --value=amount : amount in nanoWits. --fee=fee : miner fee in nanoWits. --time-lock=timestamp : optional time lock for the created output: the receiver will not be able to spend the output until the timestamp is reached. 0 means no time-lock. On success, returns the transaction hash: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 {\"jsonrpc\":\"2.0\",\"result\":\"a6c26804cf76e08ab379ea63e4aa046095dade2ae52fb3ecac90817583e61349\",\"id\":\"1\"} On error, returns the error message: Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=9999999999999999999 --fee=1 {\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32603,\"message\":\"Cannot build a transaction transferring more value than the current available balance: 9999999999999999999 + 1 > 39649999949502\"},\"id\":\"1\"} Example with time lock set to 2019-10-01 Docker docker exec witnet_node witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Binary witnet node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"} Cargo cargo run -- node send --address=twit1ulyzvnknjnndkfva636erkkp83wxhhwdfhptsr --value=1234 --fee=1 --time-lock=1569888000 {\"jsonrpc\":\"2.0\",\"result\":\"e5b55ec4930f32383e63de9316238f369ee26d89d4375521071a885fc46b4c17\",\"id\":\"1\"}","title":"send"},{"location":"node-operators/cli/#sendrequest","text":"Send a serialized data request. An example of how to create such a request can be found in the tutorial . Docker docker exec witnet_node witnet node sendRequest --hex \"data request output serialized in hexadecimal format\" Cargo cargo run -- node sendRequest --hex \"data request output serialized in hexadecimal format\" Binary witnet node sendRequest --hex \"data request output serialized in hexadecimal format\"","title":"sendRequest"},{"location":"node-operators/cli/#server","text":"Run a Witnet node server. Docker docker exec witnet_node witnet node server Binary witnet node server Cargo cargo run -- node server","title":"server"},{"location":"node-operators/cli/#splittransaction","text":"Create a value transfer transaction that splits UTXOs. The following arguments must be provided: --value=amount : amount in nanoWits. --size=size : amount in nanoWits of each UTXO. --fee=fee : miner fee in nanoWits. Docker docker exec witnet_node witnet node joinTransaction --value=100 --size=3 --fee=1 Binary witnet node joinTransaction --value=100 --size=3 --fee=1 Cargo cargo run -- node joinTransaction --value=100 --size=3 --fee=1","title":"splitTransaction"},{"location":"node-operators/cli/#transaction","text":"Print out detailed information about a transaction being queried by its hash. Docker docker exec witnet_node witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Binary witnet node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 Cargo cargo run -- node transaction f6ebdd2e3f52af8404ae3dfbf87fcfc85803a8c14a35966acca6e18585acb8f5 The hash of the transaction should be provided as a hexadecimal string. Example output: { \"jsonrpc\" : \"2.0\" , \"result\" :{ \"blockHash\" : \"0c29023ec3c8c9e1a51871a67e235168315160d9f757737c2c390f0a35ad1b24\" , \"transaction\" :{ \"ValueTransfer\" :{ \"body\" :{ \"inputs\" :[{ \"output_pointer\" : \"126549b3ea96f40bb211660d7991109d72b43e68e846ea76d4d2f6cd5a3cc7ff:1\" }], \"outputs\" :[{ \"pkh\" : \"twit12nqlkyp0zfhthfz898tplh3ns7nedcvlezx4r4\" , \"time_lock\" : 0 , \"value\" : 100 },{ \"pkh\" : \"twit10smy4dez7dpuc8yk3ck2qzgtuaa4vx3nqh5ysl\" , \"time_lock\" : 0 , \"value\" : 499999999987 }]}, \"signatures\" :[{ \"public_key\" :{ \"bytes\" :[ 109 , 158 , 138 , 247 , 58 , 8 , 183 , 138 , 57 , 113 , 147 , 147 , 136 , 177 , 252 , 244 , 33 , 147 , 143 , 200 , 255 , 89 , 208 , 192 , 214 , 81 , 128 , 224 , 219 , 180 , 136 , 155 ], \"compressed\" : 3 }, \"signature\" :{ \"Secp256k1\" :{ \"der\" :[ 48 , 68 , 2 , 32 , 25 , 163 , 14 , 139 , 5 , 92 , 35 , 157 , 90 , 73 , 162 , 93 , 88 , 67 , 117 , 152 , 104 , 178 , 208 , 225 , 123 , 131 , 236 , 59 , 240 , 136 , 18 , 55 , 79 , 168 , 12 , 218 , 2 , 32 , 76 , 68 , 59 , 125 , 99 , 133 , 74 , 11 , 232 , 70 , 157 , 116 , 68 , 151 , 70 , 39 , 187 , 132 , 190 , 110 , 245 , 214 , 29 , 179 , 198 , 182 , 24 , 133 , 137 , 177 , 187 , 142 ]}}}]}}}, \"id\" : \"1\" }","title":"transaction"},{"location":"node-operators/cli/#utxos","text":"Get the unspent transaction outputs of the node. This shows how many UTXOs are available for your node to spend or collateralize. Docker docker exec witnet_node witnet node utxos Binary witnet node utxos Cargo cargo run -- node utxos The output includes information about: Total number of utxos Total number of utxos bigger than collateral minimum Total number of utxos older than collateral coinage The flag --long can be added to the command to get a detailed list of the UTXOs and whether each of them is spendable or collateralizable at this time.","title":"utxos"},{"location":"node-operators/docker-compose-service/","text":"Run as docker-compose services \u00b6 Prerequisites \u00b6 Install the current stable release of Docker Compose: sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.4/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose Install the current stable release of parallel: sudo apt install parallel parallel --citation Test the installation of Docker Compose: docker-compose --version Clone the project's GitHub repository into your home directory: cd git clone https://github.com/witnet/witnet-operator-tools.git Go in the directory you are interested in \u00b6 for only one node \u00b6 cd witnet-operator-tools/docker/compose/bertux-operator-stable/ for several nodes (example: 5) \u00b6 cd witnet-operator-tools/docker/compose/bertux-operator-5/ Usage of docker-compose \u00b6 Start up the service: docker-compose up -d Follow the logs of the service: docker-compose logs -f When you want to stop the service: docker-compose stop When you want to remove the service: docker-compose down Every time you change the docker-compose.yaml file, you need to recreate the services by docker-compose : docker-compose down docker-compose up -d","title":"Run as docker-compose service"},{"location":"node-operators/docker-compose-service/#run-as-docker-compose-services","text":"","title":"Run as docker-compose services"},{"location":"node-operators/docker-compose-service/#prerequisites","text":"Install the current stable release of Docker Compose: sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.4/docker-compose- $( uname -s ) - $( uname -m ) \" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose Install the current stable release of parallel: sudo apt install parallel parallel --citation Test the installation of Docker Compose: docker-compose --version Clone the project's GitHub repository into your home directory: cd git clone https://github.com/witnet/witnet-operator-tools.git","title":"Prerequisites"},{"location":"node-operators/docker-compose-service/#go-in-the-directory-you-are-interested-in","text":"","title":"Go in the directory you are interested in"},{"location":"node-operators/docker-compose-service/#for-only-one-node","text":"cd witnet-operator-tools/docker/compose/bertux-operator-stable/","title":"for only one node"},{"location":"node-operators/docker-compose-service/#for-several-nodes-example-5","text":"cd witnet-operator-tools/docker/compose/bertux-operator-5/","title":"for several nodes (example: 5)"},{"location":"node-operators/docker-compose-service/#usage-of-docker-compose","text":"Start up the service: docker-compose up -d Follow the logs of the service: docker-compose logs -f When you want to stop the service: docker-compose stop When you want to remove the service: docker-compose down Every time you change the docker-compose.yaml file, you need to recreate the services by docker-compose : docker-compose down docker-compose up -d","title":"Usage of docker-compose"},{"location":"node-operators/hardware-requirements/","text":"Hardware requirements of running a Witnet node \u00b6 Witnet mining uses a probabilistic BFT-alike consensus algorithm , so no Proof-of-Work is necessary . In addition, witnet-rust is written in Rust , one of the most performance-focussed and secure programming languages available. When compiled, the resulting binary is tailored to each specific platform, which guarantees near-zero overhead . The hardware requirements for running a full node are therefore incredibly low . Obviously, the more resources you spare when provisioning your machine, the better it will perform and the less likely you are to face problems. This is a quick checklist on what to look for: At least 4GB of RAM to ensure your node does not crash during heavy network activity. A good amount of disk space (somewhere in the 100s of GBs) is better for long term storage of the blockchain. The chain is expected not to grow more than 75GB per year. Any modern laptop or desktop will run it flawlessly. Virtual private servers (VPS) should work too. Here is a tutorial to set up a Witnet node on the popular VPS service, Digital Ocean . Take into account however that some cloud providers may restrict the use of blockchain protocols . Also, your node may get poor connectivity with the rest of the network because of bucketing , especially if you are running the node from a popular IP range (for example, from a well-known VPS service such as Digital Ocean). Raspberry Pis , especially the Pi 4 Model B , are also supported and, in our experience, are a great, inexpensive way of running a Witnet node. Here is a tutorial on how to set up a Witnet node on a Raspberry Pi .","title":"Hardware requirements"},{"location":"node-operators/hardware-requirements/#hardware-requirements-of-running-a-witnet-node","text":"Witnet mining uses a probabilistic BFT-alike consensus algorithm , so no Proof-of-Work is necessary . In addition, witnet-rust is written in Rust , one of the most performance-focussed and secure programming languages available. When compiled, the resulting binary is tailored to each specific platform, which guarantees near-zero overhead . The hardware requirements for running a full node are therefore incredibly low . Obviously, the more resources you spare when provisioning your machine, the better it will perform and the less likely you are to face problems. This is a quick checklist on what to look for: At least 4GB of RAM to ensure your node does not crash during heavy network activity. A good amount of disk space (somewhere in the 100s of GBs) is better for long term storage of the blockchain. The chain is expected not to grow more than 75GB per year. Any modern laptop or desktop will run it flawlessly. Virtual private servers (VPS) should work too. Here is a tutorial to set up a Witnet node on the popular VPS service, Digital Ocean . Take into account however that some cloud providers may restrict the use of blockchain protocols . Also, your node may get poor connectivity with the rest of the network because of bucketing , especially if you are running the node from a popular IP range (for example, from a well-known VPS service such as Digital Ocean). Raspberry Pis , especially the Pi 4 Model B , are also supported and, in our experience, are a great, inexpensive way of running a Witnet node. Here is a tutorial on how to set up a Witnet node on a Raspberry Pi .","title":"Hardware requirements of running a Witnet node"},{"location":"node-operators/json-rpc/","text":"","title":"Json rpc"},{"location":"node-operators/systemd-service/","text":"Run as systemd service \u00b6 The runner.sh script automatically downloads and installs the latest version of the Witnet node software ( witnet-rust ). It can also be used to update to the latest version, since it will keep all the block chain data and the configuration file in the hidden .witnet directory. For Testnet 7.3 and greater, the configuration file needs to be customized with the public IP and port of the node, which must be set at the public_addr field in witnet.toml . Install latest version of ca-certificates to download safely from GitHub: sudo apt install ca-certificates sudo update-ca-certificates Create the witnet user dedicated to running the node: sudo adduser witnet Clone the project's GitHub repository into your home directory and enter it: cd git clone https://github.com/witnet/witnet-operator-tools.git cd witnet-operator-tools Install latest version with the witnet user dedicated to running the node: sudo -u witnet ./systemd/runner.sh Copy the witnet.service file into /lib/systemd/system/ : sudo cp systemd/witnet.service /lib/systemd/system/witnet.service Every time you change the witnet.service file, you need to reload the systemd daemon: sudo systemctl daemon-reload Enable the service: sudo systemctl enable witnet.service Start the service: sudo systemctl start witnet.service See the logs of the service: journalctl -f -u witnet.service When you want to restart the service: sudo systemctl restart witnet.service","title":"Run as systemd service"},{"location":"node-operators/systemd-service/#run-as-systemd-service","text":"The runner.sh script automatically downloads and installs the latest version of the Witnet node software ( witnet-rust ). It can also be used to update to the latest version, since it will keep all the block chain data and the configuration file in the hidden .witnet directory. For Testnet 7.3 and greater, the configuration file needs to be customized with the public IP and port of the node, which must be set at the public_addr field in witnet.toml . Install latest version of ca-certificates to download safely from GitHub: sudo apt install ca-certificates sudo update-ca-certificates Create the witnet user dedicated to running the node: sudo adduser witnet Clone the project's GitHub repository into your home directory and enter it: cd git clone https://github.com/witnet/witnet-operator-tools.git cd witnet-operator-tools Install latest version with the witnet user dedicated to running the node: sudo -u witnet ./systemd/runner.sh Copy the witnet.service file into /lib/systemd/system/ : sudo cp systemd/witnet.service /lib/systemd/system/witnet.service Every time you change the witnet.service file, you need to reload the systemd daemon: sudo systemctl daemon-reload Enable the service: sudo systemctl enable witnet.service Start the service: sudo systemctl start witnet.service See the logs of the service: journalctl -f -u witnet.service When you want to restart the service: sudo systemctl restart witnet.service","title":"Run as systemd service"},{"location":"node-operators/wallet-api/","text":"","title":"Wallet api"},{"location":"overview/concepts/","text":"What is Witnet? \u00b6 The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity. Smart Contracts Are Not What You Were Told \u00b6 Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. In reality, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is, once they are created, no one can stop them from doing exactly what they were created for. They obey their own source code, and censorship is impossible. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom . Blockchain Oracles, And Their Problem \u00b6 Given that smart contracts must be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, then you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" . The Solution: A Decentralized Oracle Network \u00b6 The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014 colloquially named witnesses - who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved, if a majority of them are incentivized to report the retrieved data honestly, and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger both for the operation of the protocol, and for the wit token (which incentives the network players to abide by the protocol and ensures they are liable for any misbehavior). Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data on behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not computationally expensive. The protocol has been designed to ensure utmost decentralization and fairness, so each witness' weight within the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the \"miners\" are not actual human beings sitting in front of a computer, manually fulfilling assignments. Instead, the \"miners\" are just computers running a software (witnet-rust) that automatically receive and execute a series of tasks. 100% Truth, 0% Trust \u00b6 Data retrieved, attested and delivered using the Witnet protocol is reliable not because of a central authority, but because it comes from anonymous nodes, incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The algorithmic reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not to spot fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"What is Witnet?"},{"location":"overview/concepts/#what-is-witnet","text":"The Witnet protocol, as outlined by the Witnet Whitepaper , allows a network of computers to act as a \"decentralized oracle\" that retrieves, attests and delivers information to smart contracts without having to place trust in a single entity.","title":"What is Witnet?"},{"location":"overview/concepts/#smart-contracts-are-not-what-you-were-told","text":"Over the last years, blockchain technology has promised to revolutionize business by allowing creation of \"smart contracts\" that, unlike paper contracts, are impossible to breach. In reality, those smart contracts are nothing more than small programs that can be run in a trustless manner. That is, once they are created, no one can stop them from doing exactly what they were created for. They obey their own source code, and censorship is impossible. If you can write a smart contract that: implements the logic of an agreement, and can execute the clauses of the contract on its own (like paying Alice or Bob depending on the outcome of some event), then you have a contract that is capable of enforcing itself and leaves no room for contestation. Boom .","title":"Smart Contracts Are Not What You Were Told"},{"location":"overview/concepts/#blockchain-oracles-and-their-problem","text":"Given that smart contracts must be completely deterministic 1 , they do not support input of data from non-deterministic sources such as APIs or websites. As a result, smart contracts are mostly isolated from the rest of the Internet, which dramatically reduces their transformative potential. At the end of the day, the output of a program does not depend solely on its source code, but also on the input data it operates upon. Of course, as the creator of a smart contract, you can create a method that allows you and only you to act as an \"oracle\" by introducing information from the outside at will. But you would be completely breaking the trustless nature of a smart contract. If trust is put in a single entity, then you have a single point of failure that can easily be hacked or corrupted. Smart contracts connected to the real world will not be completely trustless and will not release their full potential until we have ways to feed them information trustlessly. This is often called \"the oracle problem\" .","title":"Blockchain Oracles, And Their Problem"},{"location":"overview/concepts/#the-solution-a-decentralized-oracle-network","text":"The Witnet protocol aims to create an overlay network that connects smart contracts to any online data source. Sport results, stock prices, weather forecasts or even other blockchains can be easily queried (preferably through APIs). The protocol describes a distributed network of peer nodes\u2014 colloquially named witnesses - who earn Wit tokens as a reward for retrieving web data and reporting it directly to the smart contracts. The bottom line is that a considerable number of randomly selected, anonymous peers retrieving information from one or more sources can converge into a single truth about the data they retrieved, if a majority of them are incentivized to report the retrieved data honestly, and they apply a common consensus algorithm that resolves inconsistencies. This Decentralized Oracle Network (DON) maintains and distributes a block chain data structure that serves as a common ledger both for the operation of the protocol, and for the wit token (which incentives the network players to abide by the protocol and ensures they are liable for any misbehavior). Witnesses are also in charge of validating transactions in the network and bundling them into blocks that get appended to the blockchain periodically. The process by which witnesses retrieve, attest and deliver data on behalf of the smart contracts is in some way similar to mining in other blockchains. However, fulfilling these tasks and collecting the rewards is not computationally expensive. The protocol has been designed to ensure utmost decentralization and fairness, so each witness' weight within the network is not aligned to their computing power. Instead, the probability for every witness to be assigned tasks or mine new blocks is directly proportional to their past performance in terms of honesty: their reputation. Tip Of course, the \"miners\" are not actual human beings sitting in front of a computer, manually fulfilling assignments. Instead, the \"miners\" are just computers running a software (witnet-rust) that automatically receive and execute a series of tasks.","title":"The Solution: A Decentralized Oracle Network"},{"location":"overview/concepts/#100-truth-0-trust","text":"Data retrieved, attested and delivered using the Witnet protocol is reliable not because of a central authority, but because it comes from anonymous nodes, incentivized to remain honest and to compete for rewards. In addition, integrity of this data is guaranteed by a consensus algorithm that detects fraudsters, who are immediately punished. The algorithmic reputation protocol plays a central role in maintaining every participant active and honest by creating short, middle and long term incentives for them to abide by the protocol and not to tamper with the data they broker. Info Please note that Witnet's aim is not to spot fake data, but guaranteeing a 1:1 match between what is published online\u2014regardless of its truthness\u2014and the data that is eventually delivered the smart contracts. Otherwise, the contracts could have totally different output values when executed across all the nodes maintaining the blockchain, therefore causing inconsistencies that would lead to breaking the network consensus. \u21a9","title":"100% Truth, 0% Trust"},{"location":"overview/glossary/","text":"Glossary \u00b6 Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Nanowit : also nWit , the billionth fraction of a wit token. That is, 1 x 10\u22129 wit in scientific notation or standard form. One nanowit is the minimum amount of value that can exist on its own in the Witnet protocol, i.e. you cannot divide wits any further, just like you cannot divide dollars or euros further than cents. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"Data request : a digital document declaring one or more data sources and how data coming from those sources can be normalized and combined together in order to present it as a single data point to be consumed by other programs. Decentralized network : an overlay network in which multiple untrusted and independently operated computers have been set to communicate with each other as peers using a network protocol, with the purpose of fulfilling some common utility, without any of them having prominent or absolute control over the network and without chance for anyone to disrupt the functioning of the network. Nanowit : also nWit , the billionth fraction of a wit token. That is, 1 x 10\u22129 wit in scientific notation or standard form. One nanowit is the minimum amount of value that can exist on its own in the Witnet protocol, i.e. you cannot divide wits any further, just like you cannot divide dollars or euros further than cents. Oracle : an entity providing smart contracts with information from outside their containing network. Tamper resistance is the main point of smart contracts, so they should only employ decentralized oracles in which they do not need to trust the messenger . Otherwise, the oracle entity would become a single point of failure that would defeat the purpose of using smart contracts in the first place. Smart contract : a deterministic computer program with a high degree of resistance to tampering and censorship due to its concurrent execution by a decentralized network of processors owned by independent, untrusted parties whose incentives deter them from colluding to alter the output of the program.","title":"Glossary"},{"location":"overview/software/","text":"Witnet Software ecosystem \u00b6 Witnet-Rust \u00b6 Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust contains two main components: node and wallet . Here is more info on how to use them and integrate them into your own software. Sheikah \u00b6 Sheikah is a Witnet-compatible desktop wallet, as well as an integrated development environment for creating and deploying data requests. Block Explorer \u00b6 The block explorer at witnet.network allows you to explore all the blocks and transactions that exist in the chain, as well as monitoring superblock consensus, address balances, and more. Ethereum Bridge \u00b6 The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is composed of three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans Open source libraries \u00b6 Verifiable Random Functions (VRFs) \u00b6 vrf-solidity : fast and effective library for VRFs written in Solidity vrf-rs : implementation of Elliptic Curve VRFs written in Rust Elliptic Curve \u00b6 elliptic-curve-solidity : implementation of Elliptic Curve arithmetic operations written in Solidity Bonneh-Lynn-Shacham (BLS) signatures \u00b6 bls-solidity : fast and effective library for 256-bit Barreto-Naehrig (BN256) curve operations written in Solidity bls-signatures-rs : implementation of BLS signatures written in Rust","title":"Software"},{"location":"overview/software/#witnet-software-ecosystem","text":"","title":"Witnet Software ecosystem"},{"location":"overview/software/#witnet-rust","text":"Witnet-Rust is the first open-source implementation of the Witnet protocol and leverages the Rust programming language to achieve utmost speed, memory safety and fearless concurrency without compromising on performance. Witnet-Rust contains two main components: node and wallet . Here is more info on how to use them and integrate them into your own software.","title":"Witnet-Rust"},{"location":"overview/software/#sheikah","text":"Sheikah is a Witnet-compatible desktop wallet, as well as an integrated development environment for creating and deploying data requests.","title":"Sheikah"},{"location":"overview/software/#block-explorer","text":"The block explorer at witnet.network allows you to explore all the blocks and transactions that exist in the chain, as well as monitoring superblock consensus, address balances, and more.","title":"Block Explorer"},{"location":"overview/software/#ethereum-bridge","text":"The Ethereum Bridge is the component in charge of relaying data requests from Ethereum into Witnet and then communicating the results back to the originating contracts. The bridge is composed of three different pieces of software: The UsingWitnet Solidity contract that Ethereum developers can extend ( contract MyContract is UsingWitnet { ... } ). The Witnet Bridge Interface (WBI): an Ethereum contract where data requests are publicly posted to. The bridge component inside Witnet-Rust , which monitors the WBI for new requests and also scans","title":"Ethereum Bridge"},{"location":"overview/software/#open-source-libraries","text":"","title":"Open source libraries"},{"location":"overview/software/#verifiable-random-functions-vrfs","text":"vrf-solidity : fast and effective library for VRFs written in Solidity vrf-rs : implementation of Elliptic Curve VRFs written in Rust","title":"Verifiable Random Functions (VRFs)"},{"location":"overview/software/#elliptic-curve","text":"elliptic-curve-solidity : implementation of Elliptic Curve arithmetic operations written in Solidity","title":"Elliptic Curve"},{"location":"overview/software/#bonneh-lynn-shacham-bls-signatures","text":"bls-solidity : fast and effective library for 256-bit Barreto-Naehrig (BN256) curve operations written in Solidity bls-signatures-rs : implementation of BLS signatures written in Rust","title":"Bonneh-Lynn-Shacham (BLS) signatures"},{"location":"protocol/blocks/","text":"","title":"Blocks"},{"location":"protocol/reputation/","text":"Reputation System \u00b6","title":"Reputation System"},{"location":"protocol/reputation/#reputation-system","text":"","title":"Reputation System"},{"location":"protocol/serialization/","text":"","title":"Serialization"},{"location":"protocol/sortition/","text":"In Witnet, the entire network of nodes does not execute every task assigned to the network. Instead, per-task random committees composed of a subset of all available nodes are selected to perform each task. In order to be selected for one of these committees, each peer must first \"discover\" whether it is eligible. This eligibility method - somewhat comparable to someone finding out whether they hold a winning lottery ticket - is usually referred to as a \"cryptographic sortition scheme\". Typically, cryptographic sortition schemes base eligibility on whether the randomly drawn number falls below a given target value. In this case, probability of eligibility depends on the target value; the higher the value, the higher the odds that peers will be eligible. In Witnet, the probability of being eligible is biased by a node's reputation - by how \"honestly\" it has behaved in previous tasks. The cryptographic sortition in Witnet is defined as follows: VRF refers to the deterministic output of a Verifiable Random Function algorithm performed with key M i , and I i t refers to the influence (in terms of reputation) of peer i at time t. The task id represents the task which the node is trying to be eligible for. As specified, if the VRF output falls below the target value, then the node is eligible to perform the task. Each peer can individually determine its sortition without interacting with any other peer in the network. The random value is common to all peers (using the VRF random output of the last block). There are several properties that a cryptographic sortition needs to fullfil. The utilization of Verifiable Random Functions to select committees offers us the following properties: Collision resistance - it is difficult to discover two inputs that map to the same output. Pseudorandomness - the output is indistinguishable from random by anyone without the secret key. Trusted uniqueness - with a public key, a VRF input m corresponds to a unique output \u03b2. Verifiability - with a public key and a VRF output, nodes can verify whether the VRF was computed correctly. For more information on VRFs please check our medium post . Tip VRFs offer all the properties we needed for our cryptographic sortition mechanisms. If instead an ECDSA signature plus hash scheme was utilized, nodes could run their lottery as many times as they wanted (since ECDSA does not offer verifiable determinism properties).","title":"Sortition"},{"location":"protocol/transactions/","text":"","title":"Transactions"},{"location":"protocol/data-requests/overview/","text":"Witnet requests \u00b6 Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand. Request life cycle \u00b6 Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s. The RAD Engine \u00b6 The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Attest and Deliver . RAD Object Notation (RADON) \u00b6 The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted. Creating Witnet requests \u00b6 The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can write RADON, it's not the best method. The standard way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Overview"},{"location":"protocol/data-requests/overview/#witnet-requests","text":"Witnet requests are the cornerstone of the Witnet protocol. They allow clients to have witness nodes retrieve , aggregate and deliver data on their behalf on demand.","title":"Witnet requests"},{"location":"protocol/data-requests/overview/#request-life-cycle","text":"Once a Witnet request has been published by a client, it will go through 4 distinct stages: retrieval , aggregation and tally . These stages are linear and constitute a single, unidirectional data flow. \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Client \u2551 \u2551 Witnesses \u2551 \u2551 Miner \u2551 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563 \u2551 Publish \u2551 => \u2551 Retrieve => Aggregate \u2551 => \u2551 Tally \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u2551 Retrieve => Aggregate \u2551 \u2560\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2563 \u2551 ... (as many as requested) \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d For the sake of deterministic execution, data flowing through the different stages is strongly typed. The type of a value or data structure defines the operations that can be done on the data. For each stage, the data type of the input is the same as the data type of the output of previous stage. Particularly, the aggregation and tally stages gather multiple values or structures emitted by their precedent stages, so they always receive an Array , i.e. if the retrieval stage returned an Integer , the aggregation stage will start with an Array<Integer> , that is, an array of Integer s.","title":"Request life cycle"},{"location":"protocol/data-requests/overview/#the-rad-engine","text":"The RAD Engine is the component in charge of processing Witnet requests. That is, coordinating retrieval, aggregation, tally and delivery of data strictly as specified in the requests. All Witnet requests contain explicit instructions on what the RAD Engine must do during every stage. These instructions, specified using RAD Object Notation (RADON) , are interpreted by the RAD Engine. Just in case you were wondering, RAD stands for Retrieve , Attest and Deliver .","title":"The RAD Engine"},{"location":"protocol/data-requests/overview/#rad-object-notation-radon","text":"The RAD Object Notation (RADON) is a declarative, functional, strongly-typed, Non-Turing complete domain-specific language. A RADON script is formed by a list of ordered calls (tuples of operator byte codes and arguments) that are sequentially interpreted and applied by the RAD Engine on the output of the previous call. Example When applied on an Array<Integer> , this very simple 4-bytes RADON script will compute the average mean of all the Integer s: 91 92 56 03 [ [ OP_ARRAY_REDUCE , REDUCER_AVG_MEAN ] // [ 0x56, 0x03 ] ] Do not worry if you do not understand this script just yet. Keep on reading and then head yourself to the RADON encoding section for an explanation on how scripts are codified and formatted.","title":"RAD Object Notation (RADON)"},{"location":"protocol/data-requests/overview/#creating-witnet-requests","text":"The RAD Engine is only capable of interpreting well-formed RADON scripts . Even though human beings can write RADON, it's not the best method. The standard way to compose Witnet requests is using the Witnet Truffle box , which you can learn about by following the price feed tutorial . The Sheikah desktop app (currently under heavy development) is also intended to be used as an IDE for visually and safely composing and testing Witnet requests.","title":"Creating Witnet requests"},{"location":"protocol/data-requests/radon-encoding/","text":"RADON encoding \u00b6 RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this succinct (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences, and at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"Encoding"},{"location":"protocol/data-requests/radon-encoding/#radon-encoding","text":"RADON scripts are encoded using CBOR , a very efficient, compact and widely supported data structure encoding. Look for example at this succinct (28 bytes) serialized RADON script: // As Hex string 8618431874821861677765617468657218748218616474656 D701872 // As Base64 string \"hhhDGHSCGGFnd2VhdGhlchh0ghhhZHRlbXAYcg==\" Once decoded, the resulting structure will represent this RADON script: [ STRING_PARSEJSON , // 0x45 MIXED_ASMAP , // 0x74 [ MAP_GET , \"weather\" ], // [ 0x61, \"weather\" ] MIXED_ASMAP , // 0x74 [ MAP_GET , \"temp\" ], // [ 0x61, \"temp\" ] MIXED_ASFLOAT // 0x72 ] Tip RADON scripts are pure byte code sequences, and at the same time represent high-level abstractions. In the Javascript-like representation of RADON that the Witnet Truffle box uses, the script above may resemble: new Witnet . Script () . parseJSON () . asMap () . get ( \"weather\" ) . asMap () . get ( \"temp\" ) . asFloat () Constants All across this documentation, unquoted uppercase names like STRING_PARSEJSON identify different operators and constants that equate to a single byte when encoded. A list of constants can be found in the Constants section .","title":"RADON encoding"},{"location":"try/next-steps/","text":"I got my Witnet node running. What's next? \u00b6 The first minutes and hours in your node's life \u00b6 As soon as the witnet_node container is up, it will do the following things in order: Try to open connections to other nodes in the network. It needs 8 \"outbound\" connections. This should take from several seconds to a few minutes. Discover what is the tip of the block chain , and download all the blocks from that chain. This can take from several minutes to several hours. The synchronization time depends heavily on how long the block chain is, but also on your Internet bandwidth, CPU speed, memory size and speed, and storage drive write throughput. Go into Synced status . In Synced status, your node will validate transactions and blocks in real time, and it will try itself to propose block candidates and participate in resolving data requests . What to expect from your node's balance and reputation \u00b6 Getting your first block proposal accepted by the network and minting your first wit tokens is not easy, and can take from a few hours up to several days (or more!) due to the probabilistic nature of the cryptographic sortition algorithm that rules the system. As with minting blocks, being assigned a request for the first time can take some time. Once you have mined one block or resolved at least one request, your node will earn reputation and it will start getting assignments more often. Don't panic Note that it is perfectly normal for a node to show 0 \"balance\", \"reputation\", \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Read below for tips on how to increase your node's probability of mining. Stake some WIT tokens to increase your node's probability of mining \u00b6 The most efficient way to increase your node's probability of mining is to deposit some WIT tokens into its address. In doing so, your node will be able to start participating in resolving data requests, which allows it to earn reputation points and join the Active Reputation Set (ARS) \u2014 a list of nodes that have recently proved their reliability. This is crucial to increasing the mining probability because the network prioritizes blocks from identities with reputation or belonging to the ARS. Once you transfer some amount of WIT tokens to your node, staking starts to happen automatically after 12.5 hours. Getting WIT tokens Join the Witnet community and the Witnet OTC community on Telegram to find out how to get an initial amount of WIT tokens that you can put into your node. Monitoring your node's progress \u00b6 Here are some useful commands that you can use to keep track of how your node is performing in the network. A complete documentation of all the CLI methods is available in the node operator docs . nodeStats \u00b6 Among other information, this shows the synchronization state of your node, as well as counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"). Docker docker exec witnet_node witnet node nodeStats Cargo cargo run --release -- node nodeStats Binary witnet node nodeStats balance \u00b6 The balance command will print your node's current balance. Docker docker exec witnet_node witnet node balance Cargo cargo run --release -- node balance Binary witnet node balance reputation \u00b6 The reputation command will print your node's current reputation score. Docker docker exec witnet_node witnet node reputation Cargo cargo run --release -- node reputation Binary witnet node reputation Reputation is tricky Despite its name, the reputation metric that exists in the Witnet protocol is not as vital as reputation is in real life. The reputation score of a node gives a rough idea about its performance, but it is heavily influenced by randomness and luck. It is perfectly normal that the reputation score goes up and down over time, sometimes smoothly, sometimes more abruptly. Likewise, there is probably nothing wrong if your node shows 0 reputation points or is marked as \"not active\". Do not get too obsessed about it! Check ports and incoming connections \u00b6 To check if the listening port is correctly opened to the Internet, you can use a port forwarding testing tool or try to open a connection to your public IP from a device that is not in the same network as your node: Telnet # If you get stuck when running this command, it is indeed a good sign that # the connection was stablished. To exist a Telnet session, press \"Ctrl + ]\", # then write \"quit\" and press Enter. telnet your_public_ip 21337 GNU Netcat nc -vz your_public_ip:21337 The final check to verify that your port is correctly forwarded is using the peers method to look if any of the peer connections is tagged as \"inbound\": Docker docker exec witnet_node witnet node peers Cargo cargo run --release -- node peers Binary witnet node peers Multiple nodes in the same device or network Multiple Witnet nodes can run in the same device or network and still get incoming connections. This is possible by forwarding a different external port (e.g. 22337 ) to the port of your second node. However, your second node may require setting an additional parameter in its configuration file so that it is aware of the new port. Please read below how to customize the configuration file. The parameter you need to adjust is public_addr . Back up your private master key \u00b6 Doing a backup of the private master key of your node is a great way to keep your wit tokens safe. This command will print your master key into your console terminal: Docker docker exec witnet_node witnet node masterKeyExport Cargo cargo run --release -- node masterKeyExport Binary witnet node masterKeyExport You can add the --write flag to write a backup of your master key into a file in the configuration directory of your node ( ~/.witnet/config by default): Docker docker exec witnet_node witnet node masterKeyExport --write Cargo cargo run --release -- node masterKeyExport --write Binary witnet node masterKeyExport --write It is recommended to move or copy the resulting file into a safe place . Writing it into a piece of paper and keeping it somewhere safe from light, water, fire (and eyes) is the best option. Please keep this totally secret . Anyone with knowledge of this key has full access to all your wit tokens. Importing master keys is only allowed when creating a new node , as overwriting a existing key could be dangerous. The process is quite simple: Docker + nano mkdir -p ~/.witnet/config nano ~/.witnet/config/master.key # Now enter your master key into the file editor, save with Ctrl+O and exit with Ctrl+X docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust \\ node server --master-key-import /.witnet/config/master.key Docker + vim mkdir -p ~/.witnet/config vim ~/.witnet/config/master.key # Now enter your master key into the file editor, save and exit by typing Escape, then \":wq\" and Enter docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust \\ node server --master-key-import /.witnet/config/master.key Binary witnet node server --master-key-import ~/.witnet/config/master.key Never use the same master key on multiple nodes at once Operating multiple nodes with the same master key is a terrible idea. You may find your nodes exposed to double-spend issues and severe slashing. Customize configuration if needed \u00b6 A custom witnet.toml configuration file can be used to adjust some parameters of the node. The configuration file itself contains detailed explanations for each parameter. If you created your node following this guide, your witnet.toml file will be found in the ~/.witnet/config folder, right in your user's directory. You can easily edit the configuration file like this: Vim (Mac OS) vim ~/.witnet/config/witnet.toml Vim (GNU/Linux) vim ~/.witnet/config/witnet.toml Nano (GNU/Linux) nano ~/.witnet/config/witnet.toml Long term maintenance of your node \u00b6 There are some operations that are recommended from time to time to make sure your node is in perfect order: Give a look to the result of the nodeStats , balance and reputation commands. Check that you are getting incoming connections as explained above. Keep an eye on announcements for software and networks upgrades through the Witnet Community Discord and Telegram to make sure that you are running the latest release, which should give your node the best performance, liveness and security. Restart your node once in a while (e.g. docker restart witnet_node ) so that the node can perform some housekeeping operations. This helps reducing memory footprint and optimize disk space.","title":"Next Steps"},{"location":"try/next-steps/#i-got-my-witnet-node-running-whats-next","text":"","title":"I got my Witnet node running. What's next?"},{"location":"try/next-steps/#the-first-minutes-and-hours-in-your-nodes-life","text":"As soon as the witnet_node container is up, it will do the following things in order: Try to open connections to other nodes in the network. It needs 8 \"outbound\" connections. This should take from several seconds to a few minutes. Discover what is the tip of the block chain , and download all the blocks from that chain. This can take from several minutes to several hours. The synchronization time depends heavily on how long the block chain is, but also on your Internet bandwidth, CPU speed, memory size and speed, and storage drive write throughput. Go into Synced status . In Synced status, your node will validate transactions and blocks in real time, and it will try itself to propose block candidates and participate in resolving data requests .","title":"The first minutes and hours in your node's life"},{"location":"try/next-steps/#what-to-expect-from-your-nodes-balance-and-reputation","text":"Getting your first block proposal accepted by the network and minting your first wit tokens is not easy, and can take from a few hours up to several days (or more!) due to the probabilistic nature of the cryptographic sortition algorithm that rules the system. As with minting blocks, being assigned a request for the first time can take some time. Once you have mined one block or resolved at least one request, your node will earn reputation and it will start getting assignments more often. Don't panic Note that it is perfectly normal for a node to show 0 \"balance\", \"reputation\", \"blocks included\" or \"accepted commits\" for the first days of it being up. Please be patient, new identities in the system are subject to a slow start for critical security reasons. Read below for tips on how to increase your node's probability of mining.","title":"What to expect from your node's balance and reputation"},{"location":"try/next-steps/#stake-some-wit-tokens-to-increase-your-nodes-probability-of-mining","text":"The most efficient way to increase your node's probability of mining is to deposit some WIT tokens into its address. In doing so, your node will be able to start participating in resolving data requests, which allows it to earn reputation points and join the Active Reputation Set (ARS) \u2014 a list of nodes that have recently proved their reliability. This is crucial to increasing the mining probability because the network prioritizes blocks from identities with reputation or belonging to the ARS. Once you transfer some amount of WIT tokens to your node, staking starts to happen automatically after 12.5 hours. Getting WIT tokens Join the Witnet community and the Witnet OTC community on Telegram to find out how to get an initial amount of WIT tokens that you can put into your node.","title":"Stake some WIT tokens to increase your node's probability of mining"},{"location":"try/next-steps/#monitoring-your-nodes-progress","text":"Here are some useful commands that you can use to keep track of how your node is performing in the network. A complete documentation of all the CLI methods is available in the node operator docs .","title":"Monitoring your node's progress"},{"location":"try/next-steps/#nodestats","text":"Among other information, this shows the synchronization state of your node, as well as counters for proposed and accepted blocks and participations in resolving data requests (\"commitments\"). Docker docker exec witnet_node witnet node nodeStats Cargo cargo run --release -- node nodeStats Binary witnet node nodeStats","title":"nodeStats"},{"location":"try/next-steps/#balance","text":"The balance command will print your node's current balance. Docker docker exec witnet_node witnet node balance Cargo cargo run --release -- node balance Binary witnet node balance","title":"balance"},{"location":"try/next-steps/#reputation","text":"The reputation command will print your node's current reputation score. Docker docker exec witnet_node witnet node reputation Cargo cargo run --release -- node reputation Binary witnet node reputation Reputation is tricky Despite its name, the reputation metric that exists in the Witnet protocol is not as vital as reputation is in real life. The reputation score of a node gives a rough idea about its performance, but it is heavily influenced by randomness and luck. It is perfectly normal that the reputation score goes up and down over time, sometimes smoothly, sometimes more abruptly. Likewise, there is probably nothing wrong if your node shows 0 reputation points or is marked as \"not active\". Do not get too obsessed about it!","title":"reputation"},{"location":"try/next-steps/#check-ports-and-incoming-connections","text":"To check if the listening port is correctly opened to the Internet, you can use a port forwarding testing tool or try to open a connection to your public IP from a device that is not in the same network as your node: Telnet # If you get stuck when running this command, it is indeed a good sign that # the connection was stablished. To exist a Telnet session, press \"Ctrl + ]\", # then write \"quit\" and press Enter. telnet your_public_ip 21337 GNU Netcat nc -vz your_public_ip:21337 The final check to verify that your port is correctly forwarded is using the peers method to look if any of the peer connections is tagged as \"inbound\": Docker docker exec witnet_node witnet node peers Cargo cargo run --release -- node peers Binary witnet node peers Multiple nodes in the same device or network Multiple Witnet nodes can run in the same device or network and still get incoming connections. This is possible by forwarding a different external port (e.g. 22337 ) to the port of your second node. However, your second node may require setting an additional parameter in its configuration file so that it is aware of the new port. Please read below how to customize the configuration file. The parameter you need to adjust is public_addr .","title":"Check ports and incoming connections"},{"location":"try/next-steps/#back-up-your-private-master-key","text":"Doing a backup of the private master key of your node is a great way to keep your wit tokens safe. This command will print your master key into your console terminal: Docker docker exec witnet_node witnet node masterKeyExport Cargo cargo run --release -- node masterKeyExport Binary witnet node masterKeyExport You can add the --write flag to write a backup of your master key into a file in the configuration directory of your node ( ~/.witnet/config by default): Docker docker exec witnet_node witnet node masterKeyExport --write Cargo cargo run --release -- node masterKeyExport --write Binary witnet node masterKeyExport --write It is recommended to move or copy the resulting file into a safe place . Writing it into a piece of paper and keeping it somewhere safe from light, water, fire (and eyes) is the best option. Please keep this totally secret . Anyone with knowledge of this key has full access to all your wit tokens. Importing master keys is only allowed when creating a new node , as overwriting a existing key could be dangerous. The process is quite simple: Docker + nano mkdir -p ~/.witnet/config nano ~/.witnet/config/master.key # Now enter your master key into the file editor, save with Ctrl+O and exit with Ctrl+X docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust \\ node server --master-key-import /.witnet/config/master.key Docker + vim mkdir -p ~/.witnet/config vim ~/.witnet/config/master.key # Now enter your master key into the file editor, save and exit by typing Escape, then \":wq\" and Enter docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust \\ node server --master-key-import /.witnet/config/master.key Binary witnet node server --master-key-import ~/.witnet/config/master.key Never use the same master key on multiple nodes at once Operating multiple nodes with the same master key is a terrible idea. You may find your nodes exposed to double-spend issues and severe slashing.","title":"Back up your private master key"},{"location":"try/next-steps/#customize-configuration-if-needed","text":"A custom witnet.toml configuration file can be used to adjust some parameters of the node. The configuration file itself contains detailed explanations for each parameter. If you created your node following this guide, your witnet.toml file will be found in the ~/.witnet/config folder, right in your user's directory. You can easily edit the configuration file like this: Vim (Mac OS) vim ~/.witnet/config/witnet.toml Vim (GNU/Linux) vim ~/.witnet/config/witnet.toml Nano (GNU/Linux) nano ~/.witnet/config/witnet.toml","title":"Customize configuration if needed"},{"location":"try/next-steps/#long-term-maintenance-of-your-node","text":"There are some operations that are recommended from time to time to make sure your node is in perfect order: Give a look to the result of the nodeStats , balance and reputation commands. Check that you are getting incoming connections as explained above. Keep an eye on announcements for software and networks upgrades through the Witnet Community Discord and Telegram to make sure that you are running the latest release, which should give your node the best performance, liveness and security. Restart your node once in a while (e.g. docker restart witnet_node ) so that the node can perform some housekeeping operations. This helps reducing memory footprint and optimize disk space.","title":"Long term maintenance of your node"},{"location":"try/run-a-node/","text":"Running a Node in the Witnet Mainnet \u00b6 The Witnet Mainnet is open for anyone to join and and run their own full node. You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet . Hardware requirements \u00b6 Hardware requirements are listed in the node operators docs . Up and running in 1 minute, using Docker \u00b6 The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. For alternate installation methods or more complex setups, take a look at the docker-compose and systemd integrations. Firstly, you need to install Docker on the device you will be running the node from. Note: some GNU/Linux distributions require some extra steps to get Docker up and running. The Witnet docker image downloads and runs a Witnet node in in just a matter on seconds. To start a node, use: Multiline docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust One-liner docker run -d --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Windows users The home directory path is defined differently on Windows: docker run -d --name witnet-node --volume %USERPROFILE%\\.witnet\\:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Raspberry Pi users For some reason, Docker on Raspbian for all Raspberry models requires your containers to operate in privileged mode. When running the command above, simply add the --privileged flag: docker run -d --privileged --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Now what? \u00b6 There are two important things you should do now to make the most of your Witnet node: Open ports as explained below. Follow the Next Steps guide to learn how to check the node status, progress and statistics. Open your ports! \u00b6 The best way to contribute to the growth and sustainability of the Witnet network is by opening up the listening port of your node , so that other nodes in the network can download block chain data from you and your transactions can be broadcasted more quickly . For this feature to be effective, you will also need your IP address to be public (and ideally, static). If you are operating a node in your home network, you can request your ISP to assign you a static IP address or at least disable CGN on it. Depending on your setup, this will normally imply changing the settings on your router or firewall so as to forward all incoming connections to port 21337 from your external IP into the IP of the device or interface where the node is running. You can find out how to verify that your ports are open in the Next Steps guide. What about Witnet data requests? \u00b6 As soon as your node is synced, it will be able to start resolving data requests from others. You can learn how to produce Witnet requests by following the tutorial on how to create a Bitcoin price feed using Ethereum and Witnet . In addition, we will be soon releasing a user-friendly editor in the Sheikah desktop app that will enable to compose data requests and RADON scripts visually. In the meantime, you can play around with this community-built request editor .","title":"Quick Start Guide"},{"location":"try/run-a-node/#running-a-node-in-the-witnet-mainnet","text":"The Witnet Mainnet is open for anyone to join and and run their own full node. You do not need to run a Witnet node to use Witnet from your Ethereum smart contracts. If you are a smart contracts developer, what you probably want is to connect your Ethereum contracts to external APIs using Witnet .","title":"Running a Node in the Witnet Mainnet"},{"location":"try/run-a-node/#hardware-requirements","text":"Hardware requirements are listed in the node operators docs .","title":"Hardware requirements"},{"location":"try/run-a-node/#up-and-running-in-1-minute-using-docker","text":"The most convenient method for running a Witnet node is through the witnet/witnet-rust Docker image. For alternate installation methods or more complex setups, take a look at the docker-compose and systemd integrations. Firstly, you need to install Docker on the device you will be running the node from. Note: some GNU/Linux distributions require some extra steps to get Docker up and running. The Witnet docker image downloads and runs a Witnet node in in just a matter on seconds. To start a node, use: Multiline docker run -d \\ --name witnet_node \\ --volume ~/.witnet:/.witnet \\ --publish 21337:21337 \\ --restart always \\ witnet/witnet-rust One-liner docker run -d --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Windows users The home directory path is defined differently on Windows: docker run -d --name witnet-node --volume %USERPROFILE%\\.witnet\\:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust Raspberry Pi users For some reason, Docker on Raspbian for all Raspberry models requires your containers to operate in privileged mode. When running the command above, simply add the --privileged flag: docker run -d --privileged --name witnet_node --volume ~/.witnet:/.witnet --publish 21337:21337 --restart always witnet/witnet-rust","title":"Up and running in 1 minute, using Docker"},{"location":"try/run-a-node/#now-what","text":"There are two important things you should do now to make the most of your Witnet node: Open ports as explained below. Follow the Next Steps guide to learn how to check the node status, progress and statistics.","title":"Now what?"},{"location":"try/run-a-node/#open-your-ports","text":"The best way to contribute to the growth and sustainability of the Witnet network is by opening up the listening port of your node , so that other nodes in the network can download block chain data from you and your transactions can be broadcasted more quickly . For this feature to be effective, you will also need your IP address to be public (and ideally, static). If you are operating a node in your home network, you can request your ISP to assign you a static IP address or at least disable CGN on it. Depending on your setup, this will normally imply changing the settings on your router or firewall so as to forward all incoming connections to port 21337 from your external IP into the IP of the device or interface where the node is running. You can find out how to verify that your ports are open in the Next Steps guide.","title":"Open your ports!"},{"location":"try/run-a-node/#what-about-witnet-data-requests","text":"As soon as your node is synced, it will be able to start resolving data requests from others. You can learn how to produce Witnet requests by following the tutorial on how to create a Bitcoin price feed using Ethereum and Witnet . In addition, we will be soon releasing a user-friendly editor in the Sheikah desktop app that will enable to compose data requests and RADON scripts visually. In the meantime, you can play around with this community-built request editor .","title":"What about Witnet data requests?"},{"location":"try/use-from-ethereum/","text":"Using Witnet from Ethereum / Solidity \u00b6 Using Witnet as an oracle for resolving your Ethereum smart contracts is very simple, thanks to the Witnet Truffle box and the UsingWitnet Solidity library. Write your first Witnet-powered Ethereum contract \u00b6 The Witnet community has put together this comprehensive tutorial with instructions on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that anyone can get started in minutes. How can Ethereum contracts communicate with Witnet? \u00b6 Witnet is a separate blockchain. However, communication between Ethereum and Witnet is enabled via the Witnet Bridge Interface and the bridge nodes ; these nodes operate in both blockchains and get randomly selected to perform the job of relaying requests and responses back and forth between the chains. This system, which resembles the architecture of a sidechain, is better described in this Medium post . Do I need wit tokens in order to access Witnet from Ethereum? \u00b6 No :) Accessing Witnet from Ethereum requires you to neither own nor pay any wit tokens; instead, bridge nodes are paid in ETH, and spend their own wit tokens to post your requests into Witnet on your behalf.","title":"Connect your Ethereum contracts to any APIs"},{"location":"try/use-from-ethereum/#using-witnet-from-ethereum-solidity","text":"Using Witnet as an oracle for resolving your Ethereum smart contracts is very simple, thanks to the Witnet Truffle box and the UsingWitnet Solidity library.","title":"Using Witnet from Ethereum / Solidity"},{"location":"try/use-from-ethereum/#write-your-first-witnet-powered-ethereum-contract","text":"The Witnet community has put together this comprehensive tutorial with instructions on how to create a price feed Ethereum contract using Solidity, Truffle and Witnet so that anyone can get started in minutes.","title":"Write your first Witnet-powered Ethereum contract"},{"location":"try/use-from-ethereum/#how-can-ethereum-contracts-communicate-with-witnet","text":"Witnet is a separate blockchain. However, communication between Ethereum and Witnet is enabled via the Witnet Bridge Interface and the bridge nodes ; these nodes operate in both blockchains and get randomly selected to perform the job of relaying requests and responses back and forth between the chains. This system, which resembles the architecture of a sidechain, is better described in this Medium post .","title":"How can Ethereum contracts communicate with Witnet?"},{"location":"try/use-from-ethereum/#do-i-need-wit-tokens-in-order-to-access-witnet-from-ethereum","text":"No :) Accessing Witnet from Ethereum requires you to neither own nor pay any wit tokens; instead, bridge nodes are paid in ETH, and spend their own wit tokens to post your requests into Witnet on your behalf.","title":"Do I need wit tokens in order to access Witnet from Ethereum?"},{"location":"tutorials/bitcoin-price-feed/aggregations/","text":"3. Define the aggregator and tally functions \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. What is an aggregator? \u00b6 Aggregators define how to reduce or merge the result of multiple sources into a single data point. They are similar to JavaScript's .reduce() method or the fold higher-order function from many programming languages. In addition, aggregation functions give the chance to filter out any outliers by using one or more statistical primitives. Every Witnet request needs to have exactly one aggregator function . Aggregators contain zero, one or more filters . Aggregators contain exactly one reducer . When a Witnet node gets a request assigned for resolution, it retrieves every source, applies the source companion scripts on the retrieved data, collects the results into an Array , and then apply the aggregator on it, first running the filters and later the reducer. What is a tally function? \u00b6 Tallies are really similar to aggregators, but instead of merging multiple sources, they merge the results reported by multiple Witnet nodes. Let's average multiple sources \u00b6 In this case, you will be using an aggregator that filters out any outliers coming from the two sources that you defined before, and returns the average mean of the Float values that pass the filter: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean of non-outliers values. You can now continue with the tally function. Tally by average \u00b6 For this tutorial, we will be using a tally function that is quite similar to the aggregation function: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Quick recap \u00b6 At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Now it is time to put everything together and fine-tune the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"3. Define aggregator / tally"},{"location":"tutorials/bitcoin-price-feed/aggregations/#3-define-the-aggregator-and-tally-functions","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"3. Define the aggregator and tally functions"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-an-aggregator","text":"Aggregators define how to reduce or merge the result of multiple sources into a single data point. They are similar to JavaScript's .reduce() method or the fold higher-order function from many programming languages. In addition, aggregation functions give the chance to filter out any outliers by using one or more statistical primitives. Every Witnet request needs to have exactly one aggregator function . Aggregators contain zero, one or more filters . Aggregators contain exactly one reducer . When a Witnet node gets a request assigned for resolution, it retrieves every source, applies the source companion scripts on the retrieved data, collects the results into an Array , and then apply the aggregator on it, first running the filters and later the reducer.","title":"What is an aggregator?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#what-is-a-tally-function","text":"Tallies are really similar to aggregators, but instead of merging multiple sources, they merge the results reported by multiple Witnet nodes.","title":"What is a tally function?"},{"location":"tutorials/bitcoin-price-feed/aggregations/#lets-average-multiple-sources","text":"In this case, you will be using an aggregator that filters out any outliers coming from the two sources that you defined before, and returns the average mean of the Float values that pass the filter: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) That will be enough to reduce the Array containing the Float responses of the two sources into a single Float that represents the average mean of non-outliers values. You can now continue with the tally function.","title":"Let's average multiple sources"},{"location":"tutorials/bitcoin-price-feed/aggregations/#tally-by-average","text":"For this tutorial, we will be using a tally function that is quite similar to the aggregation function: // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean })","title":"Tally by average"},{"location":"tutorials/bitcoin-price-feed/aggregations/#quick-recap","text":"At this point, requests/BitcoinPrice.js should look like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviation away from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) Now it is time to put everything together and fine-tune the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/compiling/","text":"5. Compile and try the request \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compile you data request \u00b6 Compiling the request could not be easier: npm npm run compile:requests yarn yarn compile:requests The compile:requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you now take a look in the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity >= 0.7.0 < 0.9.0 ; import \"witnet-ethereum-bridge/contracts/requests/WitnetRequest.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is WitnetRequest { constructor () WitnetRequest ( hex \"0abf0108f3b5988906123b122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a13841877821864646c6173748218571903e8185b125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2786187782186663627069821866635553448218646a726174655f666c6f61748218571903e8185b1a0d0a0908051205fa3fc000001003220d0a0908051205fa3fc000001003100a186420012846308094ebdc03\" ) { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can then import and instantiate from your own contracts. Try your data request \u00b6 Data requests can be easily tried and debugged locally using the try npm task: npm npm run try yarn yarn try The first time you invoke the try npm task, it will tell you that it needs to download a native witnet_toolkit binary. Just press Enter and it will do it for you. A few seconds later, you should be presented with a \"Witnet data request local execution report\" . If you go to the latest part \u2014 the \"Tally stage\" \u2014 you can see what the result of your data request would be if executed right now: \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Witnet data request local execution report \u2551 \u2551 BitcoinPrice.sol \u2551 \u255a\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d <multiple lines ommitted> \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2524 Tally stage \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Execution time: 0.00123 ms \u2502 \u2502 Result is Integer: 47742275 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now that you have compiled and tried your data request, the next step is to write your main consumer contract . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"5. Compile and try the request"},{"location":"tutorials/bitcoin-price-feed/compiling/#5-compile-and-try-the-request","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"5. Compile  and try the request"},{"location":"tutorials/bitcoin-price-feed/compiling/#compile-you-data-request","text":"Compiling the request could not be easier: npm npm run compile:requests yarn yarn compile:requests The compile:requests npm task will: Analyze your requests for syntactic and semantic errors. Warn you of any security issues and broken incentives. Try to compile the requests into Witnet bytecode. Put the bytecode into auxiliary Solidity contracts that you can import into your own contracts. Write migration files with default constructor arguments that you can later customize. If you now take a look in the contracts/requests folder, you will notice a new file called BitcoinPrice.sol . It will contain something like this: pragma solidity >= 0.7.0 < 0.9.0 ; import \"witnet-ethereum-bridge/contracts/requests/WitnetRequest.sol\" ; // The bytecode of the BitcoinPrice request that will be sent to Witnet contract BitcoinPriceRequest is WitnetRequest { constructor () WitnetRequest ( hex \"0abf0108f3b5988906123b122468747470733a2f2f7777772e6269747374616d702e6e65742f6170692f7469636b65722f1a13841877821864646c6173748218571903e8185b125c123168747470733a2f2f6170692e636f696e6465736b2e636f6d2f76312f6270692f63757272656e7470726963652e6a736f6e1a2786187782186663627069821866635553448218646a726174655f666c6f61748218571903e8185b1a0d0a0908051205fa3fc000001003220d0a0908051205fa3fc000001003100a186420012846308094ebdc03\" ) { } } As you can see, the contract contains the byte code for the request you just wrote, exported as a Solidity contract that you can then import and instantiate from your own contracts.","title":"Compile you data request"},{"location":"tutorials/bitcoin-price-feed/compiling/#try-your-data-request","text":"Data requests can be easily tried and debugged locally using the try npm task: npm npm run try yarn yarn try The first time you invoke the try npm task, it will tell you that it needs to download a native witnet_toolkit binary. Just press Enter and it will do it for you. A few seconds later, you should be presented with a \"Witnet data request local execution report\" . If you go to the latest part \u2014 the \"Tally stage\" \u2014 you can see what the result of your data request would be if executed right now: \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 Witnet data request local execution report \u2551 \u2551 BitcoinPrice.sol \u2551 \u255a\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d <multiple lines ommitted> \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2524 Tally stage \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Execution time: 0.00123 ms \u2502 \u2502 Result is Integer: 47742275 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Now that you have compiled and tried your data request, the next step is to write your main consumer contract . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Try your data request"},{"location":"tutorials/bitcoin-price-feed/contract/","text":"6. Write your consumer contract that will handle price feed updates \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Plan the contract \u00b6 Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request is resolved, anyone will be able to call the completeUpdate and write the result into the contract state. Initialize a basic contract \u00b6 Let's start by creating a bare-bones contract and saving it as contracts/PriceFeed.sol : // SPDX-License-Identifier: MIT pragma solidity >= 0.7.0 < 0.9.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { // The public Bitcoin price point uint64 public lastPrice ; // Stores the ID of the last Witnet request uint256 public lastRequestId ; // Stores the timestamp of the last time the public price point was updated uint256 public timestamp ; // Tells if an update has been requested but not yet completed bool public pending ; // The Witnet request object, is set in the constructor Request public request ; // Emits when the price is updated event PriceUpdated ( uint64 ); // Emits when found an error decoding request result event ResultError ( string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( WitnetRequestBoard _wrb ) UsingWitnet ( _wrb ) { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } The above will: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when necessary. Make your contract inherit UsingWitnet . Define events for price updates ( PriceUpdated ) and errors ( ResultError ). Make the constructor receive the address of the Witnet Request Board ( _rb ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wrb) Construct an instance of the BitcoinPriceRequest contract, which is the Solidity representation of the data request at /requests/BitcoinPrice.js Write the requestUpdate method that launches the Witnet request \u00b6 /** * @notice Sends `request` to the WitnetRequestBoard. * @dev This method will only succeed if `pending` is 0. **/ function requestUpdate () public payable { require ( ! pending , \"Complete pending request before requesting a new one\" ); // Send the request to Witnet and store the ID for later retrieval of the result // The `_witnetPostRequest` method comes with `UsingWitnet` lastRequestId = _witnetPostRequest ( request ); // Signal that there is already a pending request pending = true ; } Write the completeUpdate method that reads the result of the Witnet request \u00b6 /** * @notice Reads the result, if ready, from the WitnetRequestBoard. * @dev The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to * protect your methods from being called before the request has been successfully * relayed into Witnet. **/ function completeUpdate () public witnetRequestResolved ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `_witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = _witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, revert the transaction with a pretty-printed error message // `witnet.isOk()`, `witnet.asUint64()` and `witnet.asErrorMessage()` come with `UsingWitnet` if ( witnet . isOk ( result )) { lastPrice = witnet . asUint64 ( result ); timestamp = block.timestamp ; emit PriceUpdated ( lastPrice ); } else { string memory errorMessage ; // Try to read the value as an error message, catch error bytes if read fails try witnet . asErrorMessage ( result ) returns ( Witnet . ErrorCodes , string memory e ) { errorMessage = e ; } catch ( bytes memory errorBytes ){ errorMessage = string ( errorBytes ); } emit ResultError ( errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; } Quick recap \u00b6 This is what the complete contract looks like: // SPDX-License-Identifier: MIT pragma solidity >= 0.7.0 < 0.9.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { // The public Bitcoin price point uint64 public lastPrice ; // Stores the ID of the last Witnet request uint256 public lastRequestId ; // Stores the timestamp of the last time the public price point was updated uint256 public timestamp ; // Tells if an update has been requested but not yet completed bool public pending ; // The Witnet request object, is set in the constructor Request public request ; // Emits when the price is updated event PriceUpdated ( uint64 ); // Emits when found an error decoding request result event ResultError ( string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( WitnetRequestBoard _wrb ) UsingWitnet ( _wrb ) { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } /** * @notice Sends `request` to the WitnetRequestBoard. * @dev This method will only succeed if `pending` is 0. **/ function requestUpdate () public payable { require ( ! pending , \"Complete pending request before requesting a new one\" ); // Send the request to Witnet and store the ID for later retrieval of the result // The `_witnetPostRequest` method comes with `UsingWitnet` lastRequestId = _witnetPostRequest ( request ); // Signal that there is already a pending request pending = true ; } /** * @notice Reads the result, if ready, from the WitnetRequestBoard. * @dev The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to * protect your methods from being called before the request has been successfully * relayed into Witnet. **/ function completeUpdate () public witnetRequestResolved ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `_witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = _witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, revert the transaction with a pretty-printed error message // `witnet.isOk()`, `witnet.asUint64()` and `witnet.asErrorMessage()` come with `UsingWitnet` if ( witnet . isOk ( result )) { lastPrice = witnet . asUint64 ( result ); timestamp = block . timestamp ; emit PriceUpdated ( lastPrice ); } else { string memory errorMessage ; // Try to read the value as an error message, catch error bytes if read fails try witnet . asErrorMessage ( result ) returns ( Witnet . ErrorCodes , string memory e ) { errorMessage = e ; } catch ( bytes memory errorBytes ){ errorMessage = string ( errorBytes ); } emit ResultError ( errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } We can now prepare to deploy ! Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"6. Write the Solidity contract"},{"location":"tutorials/bitcoin-price-feed/contract/#6-write-your-consumer-contract-that-will-handle-price-feed-updates","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"6. Write your consumer contract that will handle price feed updates"},{"location":"tutorials/bitcoin-price-feed/contract/#plan-the-contract","text":"Your contract will maintain a public variable in its state that will contain the price of a bitcoin in US Dollars. An update of the price point can be requested on demand by any interested party: Anyone will be able to call a requestUpdate method in the contract that creates a new instance of the BitcoinPrice.sol contract and send it to Witnet. Once the request is resolved, anyone will be able to call the completeUpdate and write the result into the contract state.","title":"Plan the contract"},{"location":"tutorials/bitcoin-price-feed/contract/#initialize-a-basic-contract","text":"Let's start by creating a bare-bones contract and saving it as contracts/PriceFeed.sol : // SPDX-License-Identifier: MIT pragma solidity >= 0.7.0 < 0.9.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { // The public Bitcoin price point uint64 public lastPrice ; // Stores the ID of the last Witnet request uint256 public lastRequestId ; // Stores the timestamp of the last time the public price point was updated uint256 public timestamp ; // Tells if an update has been requested but not yet completed bool public pending ; // The Witnet request object, is set in the constructor Request public request ; // Emits when the price is updated event PriceUpdated ( uint64 ); // Emits when found an error decoding request result event ResultError ( string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( WitnetRequestBoard _wrb ) UsingWitnet ( _wrb ) { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } } The above will: Import UsingWitnet.sol so your contract is Witnet-enabled. Import BitcoinPrice.sol so that you can instantiate the Witnet request when necessary. Make your contract inherit UsingWitnet . Define events for price updates ( PriceUpdated ) and errors ( ResultError ). Make the constructor receive the address of the Witnet Request Board ( _rb ) and pass it down to the UsingWitnet constructor through UsingWitnet(_wrb) Construct an instance of the BitcoinPriceRequest contract, which is the Solidity representation of the data request at /requests/BitcoinPrice.js","title":"Initialize a basic contract"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-requestupdate-method-that-launches-the-witnet-request","text":"/** * @notice Sends `request` to the WitnetRequestBoard. * @dev This method will only succeed if `pending` is 0. **/ function requestUpdate () public payable { require ( ! pending , \"Complete pending request before requesting a new one\" ); // Send the request to Witnet and store the ID for later retrieval of the result // The `_witnetPostRequest` method comes with `UsingWitnet` lastRequestId = _witnetPostRequest ( request ); // Signal that there is already a pending request pending = true ; }","title":"Write the requestUpdate method that launches the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#write-the-completeupdate-method-that-reads-the-result-of-the-witnet-request","text":"/** * @notice Reads the result, if ready, from the WitnetRequestBoard. * @dev The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to * protect your methods from being called before the request has been successfully * relayed into Witnet. **/ function completeUpdate () public witnetRequestResolved ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `_witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = _witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, revert the transaction with a pretty-printed error message // `witnet.isOk()`, `witnet.asUint64()` and `witnet.asErrorMessage()` come with `UsingWitnet` if ( witnet . isOk ( result )) { lastPrice = witnet . asUint64 ( result ); timestamp = block.timestamp ; emit PriceUpdated ( lastPrice ); } else { string memory errorMessage ; // Try to read the value as an error message, catch error bytes if read fails try witnet . asErrorMessage ( result ) returns ( Witnet . ErrorCodes , string memory e ) { errorMessage = e ; } catch ( bytes memory errorBytes ){ errorMessage = string ( errorBytes ); } emit ResultError ( errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; }","title":"Write the completeUpdate method that reads the result of the Witnet request"},{"location":"tutorials/bitcoin-price-feed/contract/#quick-recap","text":"This is what the complete contract looks like: // SPDX-License-Identifier: MIT pragma solidity >= 0.7.0 < 0.9.0 ; pragma experimental ABIEncoderV2 ; // Import the UsingWitnet library that enables interacting with Witnet import \"witnet-ethereum-bridge/contracts/UsingWitnet.sol\" ; // Import the BitcoinPrice request that you created before import \"./requests/BitcoinPrice.sol\" ; // Your contract needs to inherit from UsingWitnet contract PriceFeed is UsingWitnet { // The public Bitcoin price point uint64 public lastPrice ; // Stores the ID of the last Witnet request uint256 public lastRequestId ; // Stores the timestamp of the last time the public price point was updated uint256 public timestamp ; // Tells if an update has been requested but not yet completed bool public pending ; // The Witnet request object, is set in the constructor Request public request ; // Emits when the price is updated event PriceUpdated ( uint64 ); // Emits when found an error decoding request result event ResultError ( string ); // This constructor does a nifty trick to tell the `UsingWitnet` library where // to find the Witnet contracts on whatever Ethereum network you use. constructor ( WitnetRequestBoard _wrb ) UsingWitnet ( _wrb ) { // Instantiate the Witnet request request = new BitcoinPriceRequest (); } /** * @notice Sends `request` to the WitnetRequestBoard. * @dev This method will only succeed if `pending` is 0. **/ function requestUpdate () public payable { require ( ! pending , \"Complete pending request before requesting a new one\" ); // Send the request to Witnet and store the ID for later retrieval of the result // The `_witnetPostRequest` method comes with `UsingWitnet` lastRequestId = _witnetPostRequest ( request ); // Signal that there is already a pending request pending = true ; } /** * @notice Reads the result, if ready, from the WitnetRequestBoard. * @dev The `witnetRequestAccepted` modifier comes with `UsingWitnet` and allows to * protect your methods from being called before the request has been successfully * relayed into Witnet. **/ function completeUpdate () public witnetRequestResolved ( lastRequestId ) { require ( pending , \"There is no pending update.\" ); // Read the result of the Witnet request // The `_witnetReadResult` method comes with `UsingWitnet` Witnet . Result memory result = _witnetReadResult ( lastRequestId ); // If the Witnet request succeeded, decode the result and update the price point // If it failed, revert the transaction with a pretty-printed error message // `witnet.isOk()`, `witnet.asUint64()` and `witnet.asErrorMessage()` come with `UsingWitnet` if ( witnet . isOk ( result )) { lastPrice = witnet . asUint64 ( result ); timestamp = block . timestamp ; emit PriceUpdated ( lastPrice ); } else { string memory errorMessage ; // Try to read the value as an error message, catch error bytes if read fails try witnet . asErrorMessage ( result ) returns ( Witnet . ErrorCodes , string memory e ) { errorMessage = e ; } catch ( bytes memory errorBytes ){ errorMessage = string ( errorBytes ); } emit ResultError ( errorMessage ); } // In any case, set `pending` to false so a new update can be requested pending = false ; } } We can now prepare to deploy ! Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Quick recap"},{"location":"tutorials/bitcoin-price-feed/create-project/","text":"1. Create a new Witnet-enabled project \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Using the Witnet Truffle Box \u00b6 If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump straight to defining data sources . Project folder structure \u00b6 After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u2514\u2500\u2500 test // Scripts for testing your contracts Next step: adding data sources \u00b6 You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"1. Create a new project"},{"location":"tutorials/bitcoin-price-feed/create-project/#1-create-a-new-witnet-enabled-project","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"1. Create a new Witnet-enabled project"},{"location":"tutorials/bitcoin-price-feed/create-project/#using-the-witnet-truffle-box","text":"If you are creating a new project from scratch, the quickest way to get things working is using Truffle to download a Witnet-enabled project template: GNU/Linux, Mac OS or Linux Subsystem for Windows mkdir bitcoin-price-feed cd bitcoin-price-feed truffle unbox witnet/truffle-box You can keep reading this page to learn more about the Truffle box boilerplate, but if you are feeling impatient you can jump straight to defining data sources .","title":"Using the Witnet Truffle Box"},{"location":"tutorials/bitcoin-price-feed/create-project/#project-folder-structure","text":"After unboxing you should find yourself in a project that has been populated with the following directory structure: bitcoin-price-feed \u251c\u2500\u2500 contracts // Where your Solidity contracts will be \u2502 \u2514\u2500\u2500 requests // Where Witnet requests end up after compilation \u251c\u2500\u2500 migrations // Deployment scripts \u251c\u2500\u2500 requests // Witnet request source code (.js files) \u2514\u2500\u2500 test // Scripts for testing your contracts","title":"Project folder structure"},{"location":"tutorials/bitcoin-price-feed/create-project/#next-step-adding-data-sources","text":"You are now ready to move forward into defining the data sources to be used . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Next step: adding data sources"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/","text":"4. Put everything together and fine-tune the Witnet request \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Put everything together \u00b6 Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 25 ) // Set how many witnesses to use . setFees ( 1000000 , 1000000 ) // Set economic incentives (e.g. witness reward: 1 mWit, commit/reveal fee: 1 mWit) . setCollateral ( 10000000000 ) // Set collateral (e.g. 10 Wit) // Do not forget to export the request object export { request as default } The .setQuorum and .setFees methods are explained below. Fine-tune fees, quorum and collateral \u00b6 Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum() sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees() specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .setCollateral() establishes how much collateral do witnessing nodes need to stake in order to participate in resolving this request. Set the quorum \u00b6 . setQuorum ( witnesses , backup_witnesses ) The witnesses is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the number of witnesses, the safer the request. However, a higher number of witnesses generally means higher fees. The actual number of nodes that will resolve each request is guaranteed to be equal to the specified number. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the required number is reached. Optional arguments for .setQuorum \u00b6 The .setQuorum method accepts three more optional arguments: . setQuorum ( witnesses , minimum_consensus ) The minimum_consensus percentage allows users to define a threshold for aborting resolution of a request if the witnessing nodes did not arrive at broad consensus. That is, aggregator and tally functions will not be applied if the ratio of valid values vs. errors is below this threshold. E.g. a minimum_consensus threshold of 70 requires 70% of the witnesses to report a valid value, otherwise the request will result in an error, stating \"insufficient consensus\" . If not set, this parameter defaults to 51 . Set the fees \u00b6 . setFees ( reward , commit_and_reveal_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. These incentives include: reward : the amount of wit tokens that each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_and_reveal_fee : the amount of wit tokens that will be earned by Witnet miners for each each valid commitment/reveal transaction they include in a block. All fees are expressed in nanoWits (10^-9 wits). How can I compute the total cost of a request? The total cost of a Witnet request equals: request_fee + witnesses * (reward + 2*commit_and_reveal_fee) There are two special cases in which some fees are automatically refunded to the requester upon an eventual tally: For every valid reveal that later does not pass the filters in the tally stage (aka outliers ), you get reward back. For every missing reveal after the extra_reveal_rounds threshold is reached, you get reward + reveal_fee back. Establish the collateral \u00b6 When participating in resolving data requests (committing and revealing), witnessing nodes need to stake a certain amount of Wit tokens. It is up to you as a requester to decide what is the right amount for your use case. The more value in your contracts, the higher the collateral should be. However, take into account that if you require a high collateral amount (>250 wits), there is a chance for the request to be delayed or cancelled if there are not enough witnessing nodes willing to stake that amount. Collateral is specified on a \"per witness\" basis, that is, if your request uses 25 witnesses and requires each of them to collateralize 10 wits, your request will be secured by 25 * 10 = 250 wits. The minimum collateral is 1 wit (1000000000 nanoWits). Double check \u00b6 Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 25 ) // Set witnesses count . setFees ( 1000000 , 1000000 ) // Set economic incentives (e.g. witness reward: 1 mWit, commit/reveal fee: 1 mWit) . setCollateral ( 10000000000 ) // Set collateral (e.g. 10 Wit) // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"4. Fine-tune the request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#4-put-everything-together-and-fine-tune-the-witnet-request","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"4. Put everything together and fine-tune the Witnet request"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#put-everything-together","text":"Time to put everything together and create the Witnet.Request object that you will need to export: // This is the Witnet.Request object that needs to be exported const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 25 ) // Set how many witnesses to use . setFees ( 1000000 , 1000000 ) // Set economic incentives (e.g. witness reward: 1 mWit, commit/reveal fee: 1 mWit) . setCollateral ( 10000000000 ) // Set collateral (e.g. 10 Wit) // Do not forget to export the request object export { request as default } The .setQuorum and .setFees methods are explained below.","title":"Put everything together"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#fine-tune-fees-quorum-and-collateral","text":"Witnet requests are highly parameterizable. You can fine-tune almost every single aspect of their life cycle: .setQuorum() sets how many Witnet nodes will be \"hired\" for resolving the request. .setFees() specifies how much you want to pay for rewarding each of the Witnet nodes implicated in resolving the request. .setCollateral() establishes how much collateral do witnessing nodes need to stake in order to participate in resolving this request.","title":"Fine-tune fees, quorum and collateral"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-quorum","text":". setQuorum ( witnesses , backup_witnesses ) The witnesses is the minimum number of Witnet nodes that will be resolving each specific request. In general, the higher the number of witnesses, the safer the request. However, a higher number of witnesses generally means higher fees. The actual number of nodes that will resolve each request is guaranteed to be equal to the specified number. If for some reason the network fails to assign the request to enough nodes, it will be reassigned in every subsequent epoch to a different randomly-selected set of nodes until the required number is reached.","title":"Set the quorum"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#optional-arguments-for-setquorum","text":"The .setQuorum method accepts three more optional arguments: . setQuorum ( witnesses , minimum_consensus ) The minimum_consensus percentage allows users to define a threshold for aborting resolution of a request if the witnessing nodes did not arrive at broad consensus. That is, aggregator and tally functions will not be applied if the ratio of valid values vs. errors is below this threshold. E.g. a minimum_consensus threshold of 70 requires 70% of the witnesses to report a valid value, otherwise the request will result in an error, stating \"insufficient consensus\" . If not set, this parameter defaults to 51 .","title":"Optional arguments for .setQuorum"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#set-the-fees","text":". setFees ( reward , commit_and_reveal_fee ) Witnet allows parametrization of many of the economic incentives that affect the life cycle of your requests. These incentives include: reward : the amount of wit tokens that each of the Witnet nodes assigned to your request will earn if they honestly fulfill their commitments and reveals. commit_and_reveal_fee : the amount of wit tokens that will be earned by Witnet miners for each each valid commitment/reveal transaction they include in a block. All fees are expressed in nanoWits (10^-9 wits). How can I compute the total cost of a request? The total cost of a Witnet request equals: request_fee + witnesses * (reward + 2*commit_and_reveal_fee) There are two special cases in which some fees are automatically refunded to the requester upon an eventual tally: For every valid reveal that later does not pass the filters in the tally stage (aka outliers ), you get reward back. For every missing reveal after the extra_reveal_rounds threshold is reached, you get reward + reveal_fee back.","title":"Set the fees"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#establish-the-collateral","text":"When participating in resolving data requests (committing and revealing), witnessing nodes need to stake a certain amount of Wit tokens. It is up to you as a requester to decide what is the right amount for your use case. The more value in your contracts, the higher the collateral should be. However, take into account that if you require a high collateral amount (>250 wits), there is a chance for the request to be delayed or cancelled if there are not enough witnessing nodes willing to stake that amount. Collateral is specified on a \"per witness\" basis, that is, if your request uses 25 witnesses and requires each of them to collateralize 10 wits, your request will be secured by 25 * 10 = 250 wits. The minimum collateral is 1 wit (1000000000 nanoWits).","title":"Establish the collateral"},{"location":"tutorials/bitcoin-price-feed/fine-tuning/#double-check","text":"Time to double check everything is fine. Your BitcoinPrice.js file should look more or less like this: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const aggregator = new Witnet . Aggregator ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) // Filters out any value that is more than 1.5 times the standard // deviationaway from the average, then computes the average mean of the // values that pass the filter. const tally = new Witnet . Tally ({ filters : [ [ Witnet . Types . FILTERS . deviationStandard , 1.5 ] ], reducer : Witnet . Types . REDUCERS . averageMean }) const request = new Witnet . Request () . addSource ( bitstamp ) // Use source 1 . addSource ( coindesk ) // Use source 2 . setAggregator ( aggregator ) // Set the aggregation script . setTally ( tally ) // Set the tally script . setQuorum ( 25 ) // Set witnesses count . setFees ( 1000000 , 1000000 ) // Set economic incentives (e.g. witness reward: 1 mWit, commit/reveal fee: 1 mWit) . setCollateral ( 10000000000 ) // Set collateral (e.g. 10 Wit) // Do not forget to export the request object export { request as default } Time to go ahead and compile the request . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Double check"},{"location":"tutorials/bitcoin-price-feed/introduction/","text":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet \u00b6 What and why? \u00b6 In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 25 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum and other EVM-compatible chains is particularly convenient because you do not need to own or pay any wit tokens: you pay the bridge nodes using ETH or the chain's native token and then they spend their own wit tokens when posting your requests into Witnet on your behalf. How decentralized will this price feed be? \u00b6 None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 25 different Witnet nodes, whose reported data points are aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point. What will the code look like? \u00b6 The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox witnet/witnet-pricefeed-tutorial Ready to start? \u00b6 Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Introduction"},{"location":"tutorials/bitcoin-price-feed/introduction/#basic-witnet-tutorial-how-to-create-a-decentralized-bitcoin-price-feed-on-ethereum-with-solidity-and-witnet","text":"","title":"Basic Witnet tutorial: how to create a decentralized Bitcoin price feed on Ethereum with Solidity and Witnet"},{"location":"tutorials/bitcoin-price-feed/introduction/#what-and-why","text":"In this tutorial you will: Query two different APIs for the USD price of 1 bitcoin using 25 witnessing nodes from Witnet. Tell those nodes to aggregate the values from both APIs and report the result. Define how to tally the results reported by the different nodes into a single data point that can be trustlessly consumed by an Ethereum smart contract. Write a Solidity contract that keeps the bitcoin price in a public variable and handles updates using Witnet. Compile and deploy the entire flow into a local Ethereum network. Remember: using Witnet from Ethereum and other EVM-compatible chains is particularly convenient because you do not need to own or pay any wit tokens: you pay the bridge nodes using ETH or the chain's native token and then they spend their own wit tokens when posting your requests into Witnet on your behalf.","title":"What and why?"},{"location":"tutorials/bitcoin-price-feed/introduction/#how-decentralized-will-this-price-feed-be","text":"None of the parties involved in the process of deploying, updating and using the price feed will have any power to tamper with the integrity of the data points it provides: Once deployed, no one will be able to prevent the price feed from being updated or queried . Nobody can set the price directly . The only way to update it is through a Witnet request. The price is averaged from two different public APIs, thus mitigating their influence in the final price. The data is relayed by 25 different Witnet nodes, whose reported data points are aggregated and averaged, filtering out any outliers so as to cancel any malicious reporter who may try to leverage a slight drift of the data point.","title":"How decentralized will this price feed be?"},{"location":"tutorials/bitcoin-price-feed/introduction/#what-will-the-code-look-like","text":"The final result of this tutorial is available in this GitHub repository . You can also check it out with Truffle: mkdir PriceFeed cd PriceFeed truffle unbox witnet/witnet-pricefeed-tutorial","title":"What will the code look like?"},{"location":"tutorials/bitcoin-price-feed/introduction/#ready-to-start","text":"Let's begin by creating a new Witnet-enabled Solidity project . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Ready to start?"},{"location":"tutorials/bitcoin-price-feed/migrations/","text":"7. Migrate the contracts into an Ethereum network \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. Compile your Solidity contract \u00b6 First off, run the compile command, which compiles your Solidity contracts and then recompiles the Witnet requests: npm npm run compile yarn yarn compile You just got migration scripts for free! \u00b6 Migration scripts are very useful in Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. In addition to compiling your requests into Solidity, the Witnet request compiler that lives inside the Truffle box also writes autogenerated migration scripts for your contracts . If you look at the migrations folder, you should find these two files: 1_witnet_core.js : deploys all the Witnet-related contracts if you are deploying on a local or private network; or dynamically links them if you are on a public network. 2_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/2_user_contracts.js : const Witnet = artifacts . require ( \"Witnet\" ) const WitnetProxy = artifacts . require ( \"WitnetProxy\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = async function ( deployer ) { await deployer . link ( Witnet , [ PriceFeed ]) await deployer . deploy ( PriceFeed , WitnetProxy . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wrb , just like PriceFeed has. Customize the constructor arguments \u00b6 If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure you double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 2_user_contracts.js file altogether, then run the compiler once again. Run the deployment \u00b6 Deploying your contract into Truffle's own local Ethereum network is as simple as executing: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is good for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=ethereum.rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=ethereum.goerli deploys on the Ethereum G\u00f6rli testnet. You can find a complete list of supported networks in the addresses object in the migrations/2_user_migrations.js file, and also here . Interact with your contract \u00b6 The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"7. Deploy"},{"location":"tutorials/bitcoin-price-feed/migrations/#7-migrate-the-contracts-into-an-ethereum-network","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"7. Migrate the contracts into an Ethereum network"},{"location":"tutorials/bitcoin-price-feed/migrations/#compile-your-solidity-contract","text":"First off, run the compile command, which compiles your Solidity contracts and then recompiles the Witnet requests: npm npm run compile yarn yarn compile","title":"Compile your Solidity contract"},{"location":"tutorials/bitcoin-price-feed/migrations/#you-just-got-migration-scripts-for-free","text":"Migration scripts are very useful in Truffle. They allow you to configure how your contracts will be deployed on different Ethereum networks, set your contract's constructor arguments and link dynamic dependencies. In addition to compiling your requests into Solidity, the Witnet request compiler that lives inside the Truffle box also writes autogenerated migration scripts for your contracts . If you look at the migrations folder, you should find these two files: 1_witnet_core.js : deploys all the Witnet-related contracts if you are deploying on a local or private network; or dynamically links them if you are on a public network. 2_user_contracts.js : contains autogenerated migration scripts for your consumer contracts. Let's take a look at migrations/2_user_contracts.js : const Witnet = artifacts . require ( \"Witnet\" ) const WitnetProxy = artifacts . require ( \"WitnetProxy\" ) const PriceFeed = artifacts . require ( \"PriceFeed\" ) module . exports = async function ( deployer ) { await deployer . link ( Witnet , [ PriceFeed ]) await deployer . deploy ( PriceFeed , WitnetProxy . address ) } As you can see, the autogenerated migration script is: Dynamically linking the Witnet library to your PriceFeed contract. Deploying your PriceFeed contract. Passing the address of the Witnet Bridge Interface to the PriceFeed constructor. For the compiler to pass the address of the Witnet Bridge Interface to all your consumer contracts, it is important that they have a constructor argument called _wrb , just like PriceFeed has.","title":"You just got migration scripts for free!"},{"location":"tutorials/bitcoin-price-feed/migrations/#customize-the-constructor-arguments","text":"If your consumer contract has additional constructor arguments, the compiler will create default values for them. Before running any migration, please make sure you double-check the default arguments that the compiler inserts for you, as they may not make any sense for your specific use case. Once you modify any constructor arguments, the compiler will not rewrite those lines. If you mess them up or you want the compiler to generate default values for new constructor arguments, you can just delete those lines or remove the 2_user_contracts.js file altogether, then run the compiler once again.","title":"Customize the constructor arguments"},{"location":"tutorials/bitcoin-price-feed/migrations/#run-the-deployment","text":"Deploying your contract into Truffle's own local Ethereum network is as simple as executing: truffle migrate Please take into account that Truffle's own local network lacks any bridging capability with Witnet. This means that it is good for testing the migrations, but not for testing the entire workflow of your contracts. However, the Witnet community is working hard to overcome this limitation so that you can test your Witnet-connected contracts locally. If you want to test your contracts in a more realistic environment, you can deploy them into a public network using the --network flag: truffle migrate --network=ethereum.rinkeby deploys on the Ethereum Rinkeby testnet. truffle migrate --network=ethereum.goerli deploys on the Ethereum G\u00f6rli testnet. You can find a complete list of supported networks in the addresses object in the migrations/2_user_migrations.js file, and also here .","title":"Run the deployment"},{"location":"tutorials/bitcoin-price-feed/migrations/#interact-with-your-contract","text":"The Truffle documentation has a comprehensive guide on interacting with your contracts . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial.","title":"Interact with your contract"},{"location":"tutorials/bitcoin-price-feed/recap/","text":"Quick recap on what you've built \u00b6 Congratulations! You've now built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Join the Witnet Community Discord or Telegram groups and let us know any ideas or suggestions you have.","title":"Recap"},{"location":"tutorials/bitcoin-price-feed/recap/#quick-recap-on-what-youve-built","text":"Congratulations! You've now built your first Solidity contract using Witnet to trustlessly consume external APIs. What will you build next? Join the Witnet Community Discord or Telegram groups and let us know any ideas or suggestions you have.","title":"Quick recap on what you've built"},{"location":"tutorials/bitcoin-price-feed/sources/","text":"2. Choose and add data sources for the price feed \u00b6 This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet. A quick intro on Witnet data sources \u00b6 Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most of the time, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request \u2014 although the more sources, the higher the fees will be. Each source can have a companion script that lists the operations we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects. Choose your sources carefully \u00b6 Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, your contracts won't be either. The more reliable data sources you list, the more trust-mitigated your Witnet requests will become. In other words, your contracts will be more resilient to downtime, failure or corruption of each separate source. Introducing smart data sources \u00b6 The scripting language used in Witnet requests is very flexible: in addition to selecting specific pieces of data, you can also transform them so they are uniform and can be compared or aggregated together. For example, imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit. You can tell Witnet to transform them both to Celsius so they can be averaged. In this tutorial, you will be defining two data sources \u2014 one querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, so more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key A few things worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Key-value data structures (roughly similar to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but instead through a call to one of the .getArray(\"keyName\") , .getBoolean(\"keyName\") , .getInteger(\"keyName\") , .getFloat(\"keyName\") , .getInteger(\"keyName\") , .getMap(\"keyName\") or .getString(\"keyName\") operators. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case). Where do I put the sources? \u00b6 Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key Notice the import instruction at the top, which makes it possible to use all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file. Next step: define aggregator and tally functions \u00b6 You are done with the sources for now. Let's move forward into defining the aggregation and tally functions . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow for formats other than plain text, such as multimedia files and any kind of binaries. Therefore, source scripts will start with Bytes as the input type; it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer etc. \u21a9 One of the key features in RADON 2.0 will be implicit type casting, which will dramatically reduce the size of scripts. \u21a9","title":"2. Adding data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#2-choose-and-add-data-sources-for-the-price-feed","text":"This article is part of the beginner tutorial on creating a totally decentralized Bitcoin price feed on Ethereum with Solidity and Witnet.","title":"2. Choose and add data sources for the price feed"},{"location":"tutorials/bitcoin-price-feed/sources/#a-quick-intro-on-witnet-data-sources","text":"Data sources are each of the endpoints from which you want Witnet to retrieve the data . Most of the time, these will be the URLs of public APIs. There is no limit to the number of sources in a single Witnet request \u2014 although the more sources, the higher the fees will be. Each source can have a companion script that lists the operations we want the witnesses to apply on the retrieved data. This enables you to get the information of your interest extracted out of larger data structures like JSON objects.","title":"A quick intro on Witnet data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#choose-your-sources-carefully","text":"Just like your friends\u2014and your enemies\u2014your data sources need to be chosen wisely . The Garbage In, Garbage Out principle applies here. Regardless of the many checks-and-balances , well-designed incentives and security measures that the Witnet protocol implements, if the data sources in your Witnet requests are not reliable, your contracts won't be either. The more reliable data sources you list, the more trust-mitigated your Witnet requests will become. In other words, your contracts will be more resilient to downtime, failure or corruption of each separate source.","title":"Choose your sources carefully"},{"location":"tutorials/bitcoin-price-feed/sources/#introducing-smart-data-sources","text":"The scripting language used in Witnet requests is very flexible: in addition to selecting specific pieces of data, you can also transform them so they are uniform and can be compared or aggregated together. For example, imagine a request that queries weather data. One source may use Celsius and the other may use Fahrenheit. You can tell Witnet to transform them both to Celsius so they can be averaged. In this tutorial, you will be defining two data sources \u2014 one querying Bitstamp and the other for CoinDesk : Source 1: Bitstamp // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key Source 2: CoinDesk // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, so more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key A few things worth noticing: The operators and data types that can be used are defined by the RADON domain-specific language . Each operator is applied on the output of the previous operator, just as you would expect from Javascript method chaining or the builder pattern . Source scripts always start with a String 1 . Key-value data structures (roughly similar to Javascript objects , Python dictionaries or Solidity mappings ) are called maps . Values in maps cannot be accessed directly by name as .keyName but instead through a call to one of the .getArray(\"keyName\") , .getBoolean(\"keyName\") , .getInteger(\"keyName\") , .getFloat(\"keyName\") , .getInteger(\"keyName\") , .getMap(\"keyName\") or .getString(\"keyName\") operators. The final return type of a script is that of its last operator. For any combination of known input type and RADON script, the output type can be easily guessed upon compilation. All source scripts MUST return exactly the same type ( Float in this case).","title":"Introducing smart data sources"},{"location":"tutorials/bitcoin-price-feed/sources/#where-do-i-put-the-sources","text":"Let's create a new requests/BitcoinPrice.js file and copy the two example sources above into it: import * as Witnet from \"witnet-requests\" // Retrieves USD price of a bitcoin from the BitStamp API const bitstamp = new Witnet . Source ( \"https://www.bitstamp.net/api/ticker/\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getFloat ( \"last\" ) // Get the `Float` value associated to the `last` key // Retrieves USD price of a bitcoin from CoinDesk's \"bitcoin price index\" API // The JSON here is a bit more complex, thus more operators are needed const coindesk = new Witnet . Source ( \"https://api.coindesk.com/v1/bpi/currentprice.json\" ) . parseJSONMap () // Parse a `Map` from the retrieved `String` . getMap ( \"bpi\" ) // Get the `Map` value associated to the `bpi` key . getMap ( \"USD\" ) // Get the `Map` value associated to the `USD` key . getFloat ( \"rate_float\" ) // Get the `Float` value associated to the `rate_float` key Notice the import instruction at the top, which makes it possible to use all the tools that the Witnet Javascript library provides: import * as Witnet from \"witnet-requests\" Please make sure you save the requests/BitcoinPrice.js file.","title":"Where do I put the sources?"},{"location":"tutorials/bitcoin-price-feed/sources/#next-step-define-aggregator-and-tally-functions","text":"You are done with the sources for now. Let's move forward into defining the aggregation and tally functions . Remember: You are not alone! Join the Witnet Community Discord or Telegram . Members of the Witnet community will be happy to answer your questions and assist you through this tutorial. In future versions, the Witnet protocol will make no assumptions on what the data type of the server response will be for different data sources. This will allow for formats other than plain text, such as multimedia files and any kind of binaries. Therefore, source scripts will start with Bytes as the input type; it will be totally up to the requester to specify whether those bytes should be interpreted as a String , Integer etc. \u21a9 One of the key features in RADON 2.0 will be implicit type casting, which will dramatically reduce the size of scripts. \u21a9","title":"Next step: define aggregator and tally functions"}]}